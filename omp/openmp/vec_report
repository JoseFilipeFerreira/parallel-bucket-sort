main.c:57:5: note: ===vect_slp_analyze_bb===
main.c:58:23: note: === vect_analyze_data_refs ===
main.c:58:23: note: got vectype for stmt: _1 = MEM[(int *)a_4(D)];
vector(4) int
main.c:58:23: note: got vectype for stmt: _2 = MEM[(int *)b_5(D)];
vector(4) int
main.c:58:23: note: === vect_analyze_data_ref_accesses ===
main.c:58:23: note: not consecutive access _1 = MEM[(int *)a_4(D)];
main.c:58:23: note: not consecutive access _2 = MEM[(int *)b_5(D)];
main.c:58:23: note: not vectorized: no grouped stores in basic block.
main.c:58:23: note: ===vect_slp_analyze_bb===
main.c:16:24: note: === vect_analyze_data_refs ===
main.c:16:24: note: not vectorized: not enough data-refs in basic block.
main.c:20:12: note: === vect_analyze_data_refs ===
main.c:20:12: note: got vectype for stmt: block_arr_5->array = _2;
vector(2) long unsigned int
main.c:20:12: note: got vectype for stmt: block_arr_5->n_elem = 0;
vector(2) long unsigned int
main.c:20:12: note: got vectype for stmt: block_arr_5->max_elem = max_6(D);
vector(2) long unsigned int
main.c:20:12: note: === vect_analyze_data_ref_accesses ===
main.c:20:12: note: Detected interleaving store block_arr_5->n_elem and block_arr_5->max_elem
main.c:20:12: note: not consecutive access block_arr_5->array = _2;
main.c:20:12: note: Detected interleaving store of size 2 starting with block_arr_5->n_elem = 0;
main.c:20:12: note: === vect_pattern_recog ===
main.c:20:12: note: === vect_analyze_slp ===
main.c:20:12: note: Build SLP for block_arr_5->n_elem = 0;
main.c:20:12: note: Build SLP for block_arr_5->max_elem = max_6(D);
main.c:20:12: note: Build SLP failed: different operation in stmt block_arr_5->max_elem = max_6(D);
main.c:20:12: note: original stmt block_arr_5->n_elem = 0;
main.c:20:12: note: ===vect_slp_analyze_bb===
main.c:24:5: note: === vect_analyze_data_refs ===
main.c:24:5: note: got vectype for stmt: _1 = b_3(D)->array;
vector(2) long unsigned int
main.c:24:5: note: not vectorized: not enough data-refs in basic block.
main.c:26:1: note: === vect_analyze_data_refs ===
main.c:26:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:31
main.c:31:5: note: ===== analyze_loop_nest =====
main.c:31:5: note: === vect_analyze_loop_form ===
main.c:31:5: note: not vectorized: control flow in loop.
main.c:31:5: note: bad loop form.

Analyzing loop at main.c:35
main.c:35:9: note: ===== analyze_loop_nest =====
main.c:35:9: note: === vect_analyze_loop_form ===
main.c:35:9: note: === get_loop_niters ===
main.c:35:9: note: Symbolic number of iterations is (size_t) _34
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _7 = *_4;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_6 = _7;
vector(4) int
main.c:35:9: note: === vect_analyze_scalar_cycles ===
main.c:35:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: Access function of PHI: {w_38, +, 1}_2
main.c:35:9: note: step: 1,  init: w_38
main.c:35:9: note: Detected induction.
main.c:35:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: Access function of PHI: {0, +, 1}_2
main.c:35:9: note: step: 1,  init: 0
main.c:35:9: note: Detected induction.
main.c:35:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: === vect_pattern_recog ===
main.c:35:9: note: vect_is_simple_use: operand elem_40
main.c:35:9: note: def_stmt: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: type of def: induction
main.c:35:9: note: vect_is_simple_use: operand w_36
main.c:35:9: note: def_stmt: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: type of def: induction
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: === vect_mark_stmts_to_be_vectorized ===
main.c:35:9: note: init: phi relevant? w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: init: phi relevant? elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: init: phi relevant? .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: init: stmt relevant? _3 = elem_40 * 4;
main.c:35:9: note: init: stmt relevant? _4 = _2 + _3;
main.c:35:9: note: init: stmt relevant? w_22 = w_36 + 1;
main.c:35:9: note: init: stmt relevant? _5 = w_36 * 4;
main.c:35:9: note: init: stmt relevant? _6 = res_23(D) + _5;
main.c:35:9: note: init: stmt relevant? _7 = *_4;
main.c:35:9: note: init: stmt relevant? *_6 = _7;
main.c:35:9: note: vec_stmt_relevant_p: stmt has vdefs.
main.c:35:9: note: mark relevant 5, live 0: *_6 = _7;
main.c:35:9: note: init: stmt relevant? elem_25 = elem_40 + 1;
main.c:35:9: note: init: stmt relevant? if (elem_25 < _34)
main.c:35:9: note: worklist: examine stmt: *_6 = _7;
main.c:35:9: note: vect_is_simple_use: operand _7
main.c:35:9: note: def_stmt: _7 = *_4;
main.c:35:9: note: type of def: internal
main.c:35:9: note: mark relevant 5, live 0: _7 = *_4;
main.c:35:9: note: worklist: examine stmt: _7 = *_4;
main.c:35:9: note: === vect_analyze_data_ref_dependences ===
main.c:35:9: note: versioning for alias required: can't determine dependence between *_4 and *_6
main.c:35:9: note: mark for run-time aliasing test between *_4 and *_6
main.c:35:9: note: === vect_determine_vectorization_factor ===
main.c:35:9: note: ==> examining phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: ==> examining phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: ==> examining phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: ==> examining statement: _3 = elem_40 * 4;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _4 = _2 + _3;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: w_22 = w_36 + 1;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _5 = w_36 * 4;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _6 = res_23(D) + _5;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _7 = *_4;
main.c:35:9: note: get vectype for scalar type:  int
main.c:35:9: note: vectype: vector(4) int
main.c:35:9: note: nunits = 4
main.c:35:9: note: ==> examining statement: *_6 = _7;
main.c:35:9: note: get vectype for scalar type:  int
main.c:35:9: note: vectype: vector(4) int
main.c:35:9: note: nunits = 4
main.c:35:9: note: ==> examining statement: elem_25 = elem_40 + 1;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: if (elem_25 < _34)
main.c:35:9: note: skip.
main.c:35:9: note: vectorization factor = 4
main.c:35:9: note: === vect_analyze_slp ===
main.c:35:9: note: === vect_make_slp_decision ===
main.c:35:9: note: === vect_analyze_data_refs_alignment ===
main.c:35:9: note: vect_compute_data_ref_alignment:
main.c:35:9: note: can't force alignment of ref: *_4
main.c:35:9: note: vect_compute_data_ref_alignment:
main.c:35:9: note: can't force alignment of ref: *_6
main.c:35:9: note: === vect_prune_runtime_alias_test_list ===
main.c:35:9: note: improved number of alias checks from 1 to 1
main.c:35:9: note: === vect_enhance_data_refs_alignment ===
main.c:35:9: note: Unknown misalignment, naturally aligned
main.c:35:9: note: Unknown misalignment, naturally aligned
main.c:35:9: note: vect_can_advance_ivs_p:
main.c:35:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: vect_model_load_cost: unaligned supported by hardware.
main.c:35:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:35:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:35:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:35:9: note: Setting misalignment to -1.
main.c:35:9: note: Setting misalignment to -1.
main.c:35:9: note: Alignment of access forced using peeling.
main.c:35:9: note: Peeling for alignment will be applied.
main.c:35:9: note: Vectorizing an unaligned access.
main.c:35:9: note: === vect_analyze_loop_operations ===
main.c:35:9: note: examining phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: examining phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: examining phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: ==> examining statement: _3 = elem_40 * 4;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _4 = _2 + _3;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: w_22 = w_36 + 1;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _5 = w_36 * 4;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _6 = res_23(D) + _5;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _7 = *_4;
main.c:35:9: note: vect_is_simple_use: operand *_4
main.c:35:9: note: not ssa-name.
main.c:35:9: note: use not simple.
main.c:35:9: note: vect_is_simple_use: operand *_4
main.c:35:9: note: not ssa-name.
main.c:35:9: note: use not simple.
main.c:35:9: note: vect_model_load_cost: aligned.
main.c:35:9: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:35:9: note: ==> examining statement: *_6 = _7;
main.c:35:9: note: vect_is_simple_use: operand _7
main.c:35:9: note: def_stmt: _7 = *_4;
main.c:35:9: note: type of def: internal
main.c:35:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:35:9: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
main.c:35:9: note: ==> examining statement: elem_25 = elem_40 + 1;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: if (elem_25 < _34)
main.c:35:9: note: irrelevant.
cost model: Adding cost of checks for loop versioning aliasing.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:35:9: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 8
  Scalar iteration cost: 2
  Scalar outside cost: 1
  Vector outside cost: 20
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 13
main.c:35:9: note:   Runtime profitability threshold = 12
main.c:35:9: note:   Static estimate profitability threshold = 13
main.c:35:9: note: epilog loop required
main.c:35:9: note: vect_can_advance_ivs_p:
main.c:35:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:35:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:35:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: loop vectorized
main.c:35:9: note: === vec_transform_loop ===
main.c:35:9: note: Profitability threshold is 12 loop iterations.
main.c:35:9: note: create runtime check for data references *_6 and *_4
main.c:35:9: note: created 1 versioning for alias checks.
main.c:35:9: note: loop versioned for vectorization because of possible aliasing
main.c:35:9: note: created _2
main.c:35:9: note: niters for prolog loop: (size_t) -((unsigned long) _2 >> 2) & 3

loop at main.c:36: if (ivtmp_73 < prolog_loop_niters.22_68)
main.c:35:9: note: === vect_update_inits_of_dr ===
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: w_36 = PHI <w_22(6), w_74(23)>
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: elem_40 = PHI <elem_25(6), elem_75(23)>
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: .MEM_41 = PHI <.MEM_24(6), .MEM_76(23)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: ------>vectorizing phi: w_36 = PHI <w_22(6), w_74(31)>
main.c:35:9: note: ------>vectorizing phi: elem_40 = PHI <elem_25(6), elem_75(31)>
main.c:35:9: note: ------>vectorizing phi: .MEM_41 = PHI <.MEM_24(6), .MEM_76(31)>
main.c:35:9: note: ------>vectorizing statement: _3 = elem_40 * 4;
main.c:35:9: note: ------>vectorizing statement: _4 = _2 + _3;
main.c:35:9: note: ------>vectorizing statement: w_22 = w_36 + 1;
main.c:35:9: note: ------>vectorizing statement: _5 = w_36 * 4;
main.c:35:9: note: ------>vectorizing statement: _6 = res_23(D) + _5;
main.c:35:9: note: ------>vectorizing statement: _7 = *_4;
main.c:35:9: note: transform statement.
main.c:35:9: note: transform load. ncopies = 1
main.c:35:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *_2
main.c:35:9: note: created vectp.29_100
main.c:35:9: note: add new stmt: vect__7.30_104 = MEM[(int *)vectp.28_102];
main.c:35:9: note: ------>vectorizing statement: *_6 = _7;
main.c:35:9: note: transform statement.
main.c:35:9: note: vect_is_simple_use: operand _7
main.c:35:9: note: def_stmt: _7 = *_4;
main.c:35:9: note: type of def: internal
main.c:35:9: note: transform store. ncopies = 1
main.c:35:9: note: vect_get_vec_def_for_operand: _7
main.c:35:9: note: vect_is_simple_use: operand _7
main.c:35:9: note: def_stmt: _7 = *_4;
main.c:35:9: note: type of def: internal
main.c:35:9: note:   def_stmt =  _7 = *_4;
main.c:35:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *res_23(D) + (sizetype) (w_38 * 4)
main.c:35:9: note: created vectp.32_105
main.c:35:9: note: add new stmt: MEM[(int *)vectp.31_108] = vect__7.30_104;
main.c:35:9: note: ------>vectorizing statement: elem_25 = elem_40 + 1;
main.c:35:9: note: ------>vectorizing statement: vectp.28_103 = vectp.28_102 + 16;
main.c:35:9: note: ------>vectorizing statement: vectp.31_109 = vectp.31_108 + 16;
main.c:35:9: note: ------>vectorizing statement: if (elem_25 < _34)

loop at main.c:36: if (ivtmp_112 < bnd.24_95)
main.c:35:9: note: LOOP VECTORIZED

main.c:29:6: note: vectorized 1 loops in function.
main.c:35:9: note: loop turned into non-loop; it never loops.
main.c:35:9: note: loop with 6 iterations completely unrolled
main.c:29:6: note: loop turned into non-loop; it never loops.
main.c:29:6: note: loop with 3 iterations completely unrolled
main.c:29:6: note: ===vect_slp_analyze_bb===
main.c:31:5: note: === vect_analyze_data_refs ===
main.c:31:5: note: not vectorized: not enough data-refs in basic block.
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: got vectype for stmt: _2 = _33->array;
vector(2) long unsigned int
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _164 = *_160;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_163 = _164;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_163 = _164;
main.c:36:22: note: not consecutive access _164 = *_160;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _177 = *_173;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_176 = _177;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_176 = _177;
main.c:36:22: note: not consecutive access _177 = *_173;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _62 = *_58;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_61 = _62;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_61 = _62;
main.c:36:22: note: not consecutive access _62 = *_58;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: not enough data-refs in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: no vectype for stmt: vect__7.30_104 = MEM[(int *)vectp.28_102];
 scalar_type: vector(4) int
main.c:36:22: note: not vectorized: no vectype for stmt: MEM[(int *)vectp.31_108] = vect__7.30_104;
 scalar_type: vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: not enough data-refs in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _6 = *_3;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_5 = _6;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_5 = _6;
main.c:35:9: note: not consecutive access _6 = *_3;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _119 = *_115;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_118 = _119;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_118 = _119;
main.c:35:9: note: not consecutive access _119 = *_115;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _130 = *_126;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_129 = _130;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_129 = _130;
main.c:35:9: note: not consecutive access _130 = *_126;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _141 = *_137;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_140 = _141;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_140 = _141;
main.c:35:9: note: not consecutive access _141 = *_137;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _152 = *_148;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_151 = _152;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_151 = _152;
main.c:35:9: note: not consecutive access _152 = *_148;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:62: note: === vect_analyze_data_refs ===
main.c:35:62: note: got vectype for stmt: _86 = *_82;
vector(4) int
main.c:35:62: note: got vectype for stmt: *_85 = _86;
vector(4) int
main.c:35:62: note: === vect_analyze_data_ref_accesses ===
main.c:35:62: note: not consecutive access *_85 = _86;
main.c:35:62: note: not consecutive access _86 = *_82;
main.c:35:62: note: not vectorized: no grouped stores in basic block.
main.c:35:62: note: ===vect_slp_analyze_bb===
main.c:35:62: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _48 = *_17;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_12 = _48;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: not vectorized: not enough data-refs in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:31:5: note: === vect_analyze_data_refs ===
main.c:31:5: note: not vectorized: not enough data-refs in basic block.
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _33 = *_32;
vector(2) long unsigned int
main.c:35:9: note: got vectype for stmt: _34 = _33->n_elem;
vector(2) long unsigned int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access _34 = _33->n_elem;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:45:1: note: === vect_analyze_data_refs ===
main.c:45:1: note: not vectorized: not enough data-refs in basic block.
main.c:45:1: note: ===vect_slp_analyze_bb===
main.c:48:7: note: === vect_analyze_data_refs ===
main.c:48:7: note: got vectype for stmt: _1 = arr_15(D)->n_elem;
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: _2 = arr_15(D)->max_elem;
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: pretmp_25 = arr_15(D)->array;
vector(2) long unsigned int
main.c:48:7: note: === vect_analyze_data_ref_accesses ===
main.c:48:7: note: Detected interleaving load arr_15(D)->n_elem and arr_15(D)->max_elem
main.c:48:7: note: not consecutive access pretmp_25 = arr_15(D)->array;
main.c:48:7: note: Detected interleaving load of size 2 starting with _1 = arr_15(D)->n_elem;
main.c:48:7: note: not vectorized: no grouped stores in basic block.
main.c:48:7: note: ===vect_slp_analyze_bb===
main.c:48:7: note: ===vect_slp_analyze_bb===
main.c:49:22: note: === vect_analyze_data_refs ===
main.c:49:22: note: not vectorized: not enough data-refs in basic block.
main.c:50:23: note: === vect_analyze_data_refs ===
main.c:50:23: note: got vectype for stmt: arr_15(D)->array = _5;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: _6 = arr_15(D)->max_elem;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: arr_15(D)->max_elem = _7;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: pretmp_27 = arr_15(D)->n_elem;
vector(2) long unsigned int
main.c:50:23: note: === vect_analyze_data_ref_accesses ===
main.c:50:23: note: Detected interleaving load arr_15(D)->n_elem and arr_15(D)->max_elem
main.c:50:23: note: Detected interleaving load of size 2 starting with pretmp_27 = arr_15(D)->n_elem;
main.c:50:23: note: not consecutive access arr_15(D)->array = _5;
main.c:50:23: note: not consecutive access arr_15(D)->max_elem = _7;
main.c:50:23: note: not vectorized: no grouped stores in basic block.
main.c:50:23: note: ===vect_slp_analyze_bb===
main.c:54:1: note: === vect_analyze_data_refs ===
main.c:54:1: note: got vectype for stmt: *_11 = elem_19(D);
vector(4) int
main.c:54:1: note: got vectype for stmt: arr_15(D)->n_elem = _12;
vector(2) long unsigned int
main.c:54:1: note: === vect_analyze_data_ref_accesses ===
main.c:54:1: note: not consecutive access *_11 = elem_19(D);
main.c:54:1: note: not consecutive access arr_15(D)->n_elem = _12;
main.c:54:1: note: not vectorized: no grouped stores in basic block.

Analyzing loop at main.c:98
main.c:98:5: note: ===== analyze_loop_nest =====
main.c:98:5: note: === vect_analyze_loop_form ===
main.c:98:5: note: === get_loop_niters ===
main.c:98:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:31
main.c:31:5: note: ===== analyze_loop_nest =====
main.c:31:5: note: === vect_analyze_loop_form ===
main.c:31:5: note: not vectorized: control flow in loop.
main.c:31:5: note: bad loop form.

Analyzing loop at main.c:35
main.c:35:9: note: ===== analyze_loop_nest =====
main.c:35:9: note: === vect_analyze_loop_form ===
main.c:35:9: note: === get_loop_niters ===
main.c:35:9: note: Symbolic number of iterations is _18
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _62 = *_57;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_61 = _62;
vector(4) int
main.c:35:9: note: === vect_analyze_scalar_cycles ===
main.c:35:9: note: Analyze phi: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: Access function of PHI: {0, +, 1}_7
main.c:35:9: note: step: 1,  init: 0
main.c:35:9: note: Detected induction.
main.c:35:9: note: Analyze phi: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: Access function of PHI: {w_145, +, 1}_7
main.c:35:9: note: step: 1,  init: w_145
main.c:35:9: note: Detected induction.
main.c:35:9: note: Analyze phi: .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: === vect_pattern_recog ===
main.c:35:9: note: vect_is_simple_use: operand elem_133
main.c:35:9: note: def_stmt: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: type of def: induction
main.c:35:9: note: vect_is_simple_use: operand w_131
main.c:35:9: note: def_stmt: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: type of def: induction
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: === vect_mark_stmts_to_be_vectorized ===
main.c:35:9: note: init: phi relevant? elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: init: phi relevant? w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: init: phi relevant? .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: init: stmt relevant? _56 = elem_133 * 4;
main.c:35:9: note: init: stmt relevant? _57 = _54 + _56;
main.c:35:9: note: init: stmt relevant? w_59 = w_131 + 1;
main.c:35:9: note: init: stmt relevant? _60 = w_131 * 4;
main.c:35:9: note: init: stmt relevant? _61 = arr_36(D) + _60;
main.c:35:9: note: init: stmt relevant? _62 = *_57;
main.c:35:9: note: init: stmt relevant? *_61 = _62;
main.c:35:9: note: vec_stmt_relevant_p: stmt has vdefs.
main.c:35:9: note: mark relevant 5, live 0: *_61 = _62;
main.c:35:9: note: init: stmt relevant? elem_63 = elem_133 + 1;
main.c:35:9: note: init: stmt relevant? if (_18 > elem_63)
main.c:35:9: note: worklist: examine stmt: *_61 = _62;
main.c:35:9: note: vect_is_simple_use: operand _62
main.c:35:9: note: def_stmt: _62 = *_57;
main.c:35:9: note: type of def: internal
main.c:35:9: note: mark relevant 5, live 0: _62 = *_57;
main.c:35:9: note: worklist: examine stmt: _62 = *_57;
main.c:35:9: note: === vect_analyze_data_ref_dependences ===
main.c:35:9: note: versioning for alias required: can't determine dependence between *_57 and *_61
main.c:35:9: note: mark for run-time aliasing test between *_57 and *_61
main.c:35:9: note: === vect_determine_vectorization_factor ===
main.c:35:9: note: ==> examining phi: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: ==> examining phi: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: ==> examining phi: .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: ==> examining statement: _56 = elem_133 * 4;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _57 = _54 + _56;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: w_59 = w_131 + 1;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _60 = w_131 * 4;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _61 = arr_36(D) + _60;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: _62 = *_57;
main.c:35:9: note: get vectype for scalar type:  int
main.c:35:9: note: vectype: vector(4) int
main.c:35:9: note: nunits = 4
main.c:35:9: note: ==> examining statement: *_61 = _62;
main.c:35:9: note: get vectype for scalar type:  int
main.c:35:9: note: vectype: vector(4) int
main.c:35:9: note: nunits = 4
main.c:35:9: note: ==> examining statement: elem_63 = elem_133 + 1;
main.c:35:9: note: skip.
main.c:35:9: note: ==> examining statement: if (_18 > elem_63)
main.c:35:9: note: skip.
main.c:35:9: note: vectorization factor = 4
main.c:35:9: note: === vect_analyze_slp ===
main.c:35:9: note: === vect_make_slp_decision ===
main.c:35:9: note: === vect_analyze_data_refs_alignment ===
main.c:35:9: note: vect_compute_data_ref_alignment:
main.c:35:9: note: can't force alignment of ref: *_57
main.c:35:9: note: vect_compute_data_ref_alignment:
main.c:35:9: note: can't force alignment of ref: *_61
main.c:35:9: note: === vect_prune_runtime_alias_test_list ===
main.c:35:9: note: improved number of alias checks from 1 to 1
main.c:35:9: note: === vect_enhance_data_refs_alignment ===
main.c:35:9: note: Unknown misalignment, naturally aligned
main.c:35:9: note: Unknown misalignment, naturally aligned
main.c:35:9: note: vect_can_advance_ivs_p:
main.c:35:9: note: Analyze phi: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: Analyze phi: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: Analyze phi: .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: vect_model_load_cost: unaligned supported by hardware.
main.c:35:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:35:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:35:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:35:9: note: Setting misalignment to -1.
main.c:35:9: note: Setting misalignment to -1.
main.c:35:9: note: Alignment of access forced using peeling.
main.c:35:9: note: Peeling for alignment will be applied.
main.c:35:9: note: Vectorizing an unaligned access.
main.c:35:9: note: === vect_analyze_loop_operations ===
main.c:35:9: note: examining phi: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: examining phi: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: examining phi: .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: ==> examining statement: _56 = elem_133 * 4;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _57 = _54 + _56;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: w_59 = w_131 + 1;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _60 = w_131 * 4;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _61 = arr_36(D) + _60;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: _62 = *_57;
main.c:35:9: note: vect_is_simple_use: operand *_57
main.c:35:9: note: not ssa-name.
main.c:35:9: note: use not simple.
main.c:35:9: note: vect_is_simple_use: operand *_57
main.c:35:9: note: not ssa-name.
main.c:35:9: note: use not simple.
main.c:35:9: note: vect_model_load_cost: aligned.
main.c:35:9: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:35:9: note: ==> examining statement: *_61 = _62;
main.c:35:9: note: vect_is_simple_use: operand _62
main.c:35:9: note: def_stmt: _62 = *_57;
main.c:35:9: note: type of def: internal
main.c:35:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:35:9: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
main.c:35:9: note: ==> examining statement: elem_63 = elem_133 + 1;
main.c:35:9: note: irrelevant.
main.c:35:9: note: ==> examining statement: if (_18 > elem_63)
main.c:35:9: note: irrelevant.
cost model: Adding cost of checks for loop versioning aliasing.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:35:9: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 8
  Scalar iteration cost: 2
  Scalar outside cost: 1
  Vector outside cost: 20
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 13
main.c:35:9: note:   Runtime profitability threshold = 12
main.c:35:9: note:   Static estimate profitability threshold = 13
main.c:35:9: note: epilog loop required
main.c:35:9: note: vect_can_advance_ivs_p:
main.c:35:9: note: Analyze phi: elem_133 = PHI <elem_63(23), 0(21)>
main.c:35:9: note: Analyze phi: w_131 = PHI <w_59(23), w_145(21)>
main.c:35:9: note: Analyze phi: .MEM_126 = PHI <.MEM_76(23), .MEM_146(21)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: loop vectorized
main.c:35:9: note: === vec_transform_loop ===
main.c:35:9: note: Profitability threshold is 12 loop iterations.
main.c:35:9: note: create runtime check for data references *_61 and *_57
main.c:35:9: note: created 1 versioning for alias checks.
main.c:35:9: note: loop versioned for vectorization because of possible aliasing
main.c:35:9: note: created _54
main.c:35:9: note: niters for prolog loop: (long unsigned int) -((unsigned long) _54 >> 2) & 3

loop at main.c:36: if (ivtmp_22 < prolog_loop_niters.60_30)
main.c:35:9: note: === vect_update_inits_of_dr ===
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: elem_133 = PHI <elem_63(23), elem_21(43)>
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: w_131 = PHI <w_59(23), w_5(43)>
main.c:35:9: note: vect_update_ivs_after_vectorizer: phi: .MEM_126 = PHI <.MEM_76(23), .MEM_174(43)>
main.c:35:9: note: reduc or virtual phi. skip.
main.c:35:9: note: ------>vectorizing phi: elem_133 = PHI <elem_63(23), elem_21(51)>
main.c:35:9: note: ------>vectorizing phi: w_131 = PHI <w_59(23), w_5(51)>
main.c:35:9: note: ------>vectorizing phi: .MEM_126 = PHI <.MEM_76(23), .MEM_174(51)>
main.c:35:9: note: ------>vectorizing statement: _56 = elem_133 * 4;
main.c:35:9: note: ------>vectorizing statement: _57 = _54 + _56;
main.c:35:9: note: ------>vectorizing statement: w_59 = w_131 + 1;
main.c:35:9: note: ------>vectorizing statement: _60 = w_131 * 4;
main.c:35:9: note: ------>vectorizing statement: _61 = arr_36(D) + _60;
main.c:35:9: note: ------>vectorizing statement: _62 = *_57;
main.c:35:9: note: transform statement.
main.c:35:9: note: transform load. ncopies = 1
main.c:35:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *_54
main.c:35:9: note: created vectp.67_180
main.c:35:9: note: add new stmt: vect__62.68_184 = MEM[(int *)vectp.66_182];
main.c:35:9: note: ------>vectorizing statement: *_61 = _62;
main.c:35:9: note: transform statement.
main.c:35:9: note: vect_is_simple_use: operand _62
main.c:35:9: note: def_stmt: _62 = *_57;
main.c:35:9: note: type of def: internal
main.c:35:9: note: transform store. ncopies = 1
main.c:35:9: note: vect_get_vec_def_for_operand: _62
main.c:35:9: note: vect_is_simple_use: operand _62
main.c:35:9: note: def_stmt: _62 = *_57;
main.c:35:9: note: type of def: internal
main.c:35:9: note:   def_stmt =  _62 = *_57;
main.c:35:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *arr_36(D) + (sizetype) (w_145 * 4)
main.c:35:9: note: created vectp.70_185
main.c:35:9: note: add new stmt: MEM[(int *)vectp.69_188] = vect__62.68_184;
main.c:35:9: note: ------>vectorizing statement: elem_63 = elem_133 + 1;
main.c:35:9: note: ------>vectorizing statement: vectp.66_183 = vectp.66_182 + 16;
main.c:35:9: note: ------>vectorizing statement: vectp.69_189 = vectp.69_188 + 16;
main.c:35:9: note: ------>vectorizing statement: if (_18 > elem_63)

loop at main.c:36: if (ivtmp_192 < bnd.62_175)
main.c:35:9: note: LOOP VECTORIZED


Analyzing loop at main.c:93
main.c:93:5: note: ===== analyze_loop_nest =====
main.c:93:5: note: === vect_analyze_loop_form ===
main.c:93:5: note: === get_loop_niters ===
main.c:93:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:82
main.c:82:5: note: ===== analyze_loop_nest =====
main.c:82:5: note: === vect_analyze_loop_form ===
main.c:82:5: note: not vectorized: control flow in loop.
main.c:82:5: note: bad loop form.

Analyzing loop at main.c:79
main.c:79:5: note: ===== analyze_loop_nest =====
main.c:79:5: note: === vect_analyze_loop_form ===
main.c:79:5: note: === get_loop_niters ===
main.c:79:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:69
main.c:69:5: note: ===== analyze_loop_nest =====
main.c:69:5: note: === vect_analyze_loop_form ===
main.c:69:5: note: === get_loop_niters ===
main.c:69:5: note: Symbolic number of iterations is size_34(D) + 18446744073709551615
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _4 = *_3;
vector(4) int
main.c:69:5: note: === vect_analyze_scalar_cycles ===
main.c:69:5: note: Analyze phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: Access function of PHI: max_69
main.c:69:5: note: Analyze phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: Access function of PHI: min_27
main.c:69:5: note: Analyze phi: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: Access function of PHI: {1, +, 1}_1
main.c:69:5: note: step: 1,  init: 1
main.c:69:5: note: Detected induction.
main.c:69:5: note: Analyze phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: detected reduction: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: Detected reduction.
main.c:69:5: note: Analyze phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: detected reduction: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: Detected reduction.
main.c:69:5: note: === vect_pattern_recog ===
main.c:69:5: note: vect_is_simple_use: operand i_134
main.c:69:5: note: def_stmt: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: type of def: induction
main.c:69:5: note: === vect_analyze_data_ref_accesses ===
main.c:69:5: note: === vect_mark_stmts_to_be_vectorized ===
main.c:69:5: note: init: phi relevant? max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: init: phi relevant? min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: init: phi relevant? i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: init: stmt relevant? _2 = i_134 * 4;
main.c:69:5: note: init: stmt relevant? _3 = arr_36(D) + _2;
main.c:69:5: note: init: stmt relevant? _4 = *_3;
main.c:69:5: note: init: stmt relevant? max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: vec_stmt_relevant_p: used out of loop.
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vec_stmt_relevant_p: stmt live but not relevant.
main.c:69:5: note: mark relevant 1, live 1: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: init: stmt relevant? min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: vec_stmt_relevant_p: used out of loop.
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vec_stmt_relevant_p: stmt live but not relevant.
main.c:69:5: note: mark relevant 1, live 1: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: init: stmt relevant? i_50 = i_134 + 1;
main.c:69:5: note: init: stmt relevant? if (size_34(D) > i_50)
main.c:69:5: note: worklist: examine stmt: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: mark relevant 1, live 0: _4 = *_3;
main.c:69:5: note: vect_is_simple_use: operand min_27
main.c:69:5: note: def_stmt: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: mark relevant 1, live 0: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: worklist: examine stmt: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: vect_is_simple_use: operand min_38
main.c:69:5: note: def_stmt: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: type of def: reduction
main.c:69:5: note: reduc-stmt defining reduc-phi in the same nest.
main.c:69:5: note: vect_is_simple_use: operand max_37
main.c:69:5: note: def_stmt: max_37 = *arr_36(D);
main.c:69:5: note: type of def: external
main.c:69:5: note: def_stmt is out of loop.
main.c:69:5: note: worklist: examine stmt: _4 = *_3;
main.c:69:5: note: worklist: examine stmt: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: mark relevant 1, live 0: _4 = *_3;
main.c:69:5: note: already marked relevant/live.
main.c:69:5: note: vect_is_simple_use: operand max_69
main.c:69:5: note: def_stmt: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: mark relevant 1, live 0: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: worklist: examine stmt: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: vect_is_simple_use: operand max_70
main.c:69:5: note: def_stmt: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: type of def: reduction
main.c:69:5: note: reduc-stmt defining reduc-phi in the same nest.
main.c:69:5: note: vect_is_simple_use: operand max_37
main.c:69:5: note: def_stmt: max_37 = *arr_36(D);
main.c:69:5: note: type of def: external
main.c:69:5: note: def_stmt is out of loop.
main.c:69:5: note: === vect_analyze_data_ref_dependences ===
main.c:69:5: note: === vect_determine_vectorization_factor ===
main.c:69:5: note: ==> examining phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: nunits = 4
main.c:69:5: note: ==> examining phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: nunits = 4
main.c:69:5: note: ==> examining phi: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: ==> examining statement: _2 = i_134 * 4;
main.c:69:5: note: skip.
main.c:69:5: note: ==> examining statement: _3 = arr_36(D) + _2;
main.c:69:5: note: skip.
main.c:69:5: note: ==> examining statement: _4 = *_3;
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: nunits = 4
main.c:69:5: note: ==> examining statement: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: nunits = 4
main.c:69:5: note: ==> examining statement: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: get vectype for scalar type:  int
main.c:69:5: note: vectype: vector(4) int
main.c:69:5: note: nunits = 4
main.c:69:5: note: ==> examining statement: i_50 = i_134 + 1;
main.c:69:5: note: skip.
main.c:69:5: note: ==> examining statement: if (size_34(D) > i_50)
main.c:69:5: note: skip.
main.c:69:5: note: vectorization factor = 4
main.c:69:5: note: === vect_analyze_slp ===
main.c:69:5: note: Build SLP for min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: Build SLP for max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: Build SLP failed: different operation in stmt max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: original stmt min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: === vect_make_slp_decision ===
main.c:69:5: note: === vect_analyze_data_refs_alignment ===
main.c:69:5: note: vect_compute_data_ref_alignment:
main.c:69:5: note: can't force alignment of ref: *_3
main.c:69:5: note: === vect_prune_runtime_alias_test_list ===
main.c:69:5: note: === vect_enhance_data_refs_alignment ===
main.c:69:5: note: Unknown misalignment, naturally aligned
main.c:69:5: note: vect_can_advance_ivs_p:
main.c:69:5: note: Analyze phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: Analyze phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: Analyze phi: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: Alignment of access forced using peeling.
main.c:69:5: note: Peeling for alignment will be applied.
main.c:69:5: note: === vect_analyze_loop_operations ===
main.c:69:5: note: examining phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: examining phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: examining phi: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: ==> examining statement: _2 = i_134 * 4;
main.c:69:5: note: irrelevant.
main.c:69:5: note: ==> examining statement: _3 = arr_36(D) + _2;
main.c:69:5: note: irrelevant.
main.c:69:5: note: ==> examining statement: _4 = *_3;
main.c:69:5: note: vect_is_simple_use: operand *_3
main.c:69:5: note: not ssa-name.
main.c:69:5: note: use not simple.
main.c:69:5: note: vect_is_simple_use: operand *_3
main.c:69:5: note: not ssa-name.
main.c:69:5: note: use not simple.
main.c:69:5: note: vect_model_load_cost: aligned.
main.c:69:5: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:69:5: note: ==> examining statement: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vect_is_simple_use: operand max_69
main.c:69:5: note: def_stmt: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: detected reduction: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 1, prologue_cost = 1, epilogue_cost = 5 .
main.c:69:5: note: ==> examining statement: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vect_is_simple_use: operand min_27
main.c:69:5: note: def_stmt: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: detected reduction: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 1, prologue_cost = 1, epilogue_cost = 5 .
main.c:69:5: note: ==> examining statement: i_50 = i_134 + 1;
main.c:69:5: note: irrelevant.
main.c:69:5: note: ==> examining statement: if (size_34(D) > i_50)
main.c:69:5: note: irrelevant.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:69:5: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 20
  Scalar iteration cost: 3
  Scalar outside cost: 7
  Vector outside cost: 32
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 10
main.c:69:5: note:   Runtime profitability threshold = 9
main.c:69:5: note:   Static estimate profitability threshold = 15
main.c:69:5: note: epilog loop required
main.c:69:5: note: vect_can_advance_ivs_p:
main.c:69:5: note: Analyze phi: max_69 = PHI <max_70(8), max_37(5)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: Analyze phi: min_27 = PHI <min_38(8), max_37(5)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: Analyze phi: i_134 = PHI <i_50(8), 1(5)>
main.c:69:5: note: loop vectorized
main.c:69:5: note: === vec_transform_loop ===
main.c:69:5: note: Profitability threshold is 9 loop iterations.
main.c:69:5: note: created vectp_arr.72_206
main.c:69:5: note: niters for prolog loop: (size_t) -((unsigned long) vectp_arr.72_206 >> 2) & 3

loop at main.c:70: if (ivtmp_212 < prolog_loop_niters.73_207)
main.c:69:5: note: === vect_update_inits_of_dr ===
main.c:69:5: note: vect_update_ivs_after_vectorizer: phi: max_69 = PHI <max_70(8), max_213(57)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: vect_update_ivs_after_vectorizer: phi: min_27 = PHI <min_38(8), min_214(57)>
main.c:69:5: note: reduc or virtual phi. skip.
main.c:69:5: note: vect_update_ivs_after_vectorizer: phi: i_134 = PHI <i_50(8), i_215(57)>
main.c:69:5: note: ------>vectorizing phi: max_69 = PHI <max_70(8), max_213(65)>
main.c:69:5: note: ------>vectorizing phi: min_27 = PHI <min_38(8), min_214(65)>
main.c:69:5: note: ------>vectorizing phi: i_134 = PHI <i_50(8), i_215(65)>
main.c:69:5: note: ------>vectorizing statement: _2 = i_134 * 4;
main.c:69:5: note: ------>vectorizing statement: _3 = arr_36(D) + _2;
main.c:69:5: note: ------>vectorizing statement: _4 = *_3;
main.c:69:5: note: transform statement.
main.c:69:5: note: transform load. ncopies = 1
main.c:69:5: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *arr_36(D)
main.c:69:5: note: created vectp_arr.79_237
main.c:69:5: note: add new stmt: vect__4.80_242 = MEM[(int *)vectp_arr.78_240];
main.c:69:5: note: ------>vectorizing statement: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: transform statement.
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vect_is_simple_use: operand max_69
main.c:69:5: note: def_stmt: max_69 = PHI <max_70(8), max_213(65)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: detected reduction: max_70 = MAX_EXPR <_4, max_69>;
main.c:69:5: note: reduc op not supported by target.
main.c:69:5: note: transform reduction.
main.c:69:5: note: vect_get_vec_def_for_operand: _4
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note:   def_stmt =  _4 = *_3;
main.c:69:5: note: add new stmt: vect_max_70.81_244 = MAX_EXPR <vect__4.80_242, vect_max_70.81_243>;
main.c:69:5: note: vect_is_simple_use: operand max_213
main.c:69:5: note: def_stmt: max_213 = PHI <max_203(53), max_37(52)>
main.c:69:5: note: type of def: external
main.c:69:5: note: vect_get_vec_def_for_operand: max_213
main.c:69:5: note: vect_is_simple_use: operand max_213
main.c:69:5: note: def_stmt: max_213 = PHI <max_203(53), max_37(52)>
main.c:69:5: note: type of def: external
main.c:69:5: note:   def_stmt =  max_213 = PHI <max_203(53), max_37(52)>
main.c:69:5: note: created new init_stmt: vect_cst__245 = {max_213, max_213, max_213, max_213};
main.c:69:5: note: transform reduction: created def-use cycle: vect_max_70.81_243 = PHI <vect_max_70.81_244(8), vect_cst__245(65)>
vect_max_70.81_244 = MAX_EXPR <vect__4.80_242, vect_max_70.81_243>;
main.c:69:5: note: Reduce using vector shifts
main.c:69:5: note: extract scalar result
main.c:69:5: note: ------>vectorizing statement: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: transform statement.
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note: vect_is_simple_use: operand min_27
main.c:69:5: note: def_stmt: min_27 = PHI <min_38(8), min_214(65)>
main.c:69:5: note: type of def: reduction
main.c:69:5: note: detected reduction: min_38 = MIN_EXPR <_4, min_27>;
main.c:69:5: note: reduc op not supported by target.
main.c:69:5: note: transform reduction.
main.c:69:5: note: vect_get_vec_def_for_operand: _4
main.c:69:5: note: vect_is_simple_use: operand _4
main.c:69:5: note: def_stmt: _4 = *_3;
main.c:69:5: note: type of def: internal
main.c:69:5: note:   def_stmt =  _4 = *_3;
main.c:69:5: note: add new stmt: vect_min_38.84_253 = MIN_EXPR <vect__4.80_242, vect_min_38.84_252>;
main.c:69:5: note: vect_is_simple_use: operand min_214
main.c:69:5: note: def_stmt: min_214 = PHI <min_204(53), max_37(52)>
main.c:69:5: note: type of def: external
main.c:69:5: note: vect_get_vec_def_for_operand: min_214
main.c:69:5: note: vect_is_simple_use: operand min_214
main.c:69:5: note: def_stmt: min_214 = PHI <min_204(53), max_37(52)>
main.c:69:5: note: type of def: external
main.c:69:5: note:   def_stmt =  min_214 = PHI <min_204(53), max_37(52)>
main.c:69:5: note: created new init_stmt: vect_cst__254 = {min_214, min_214, min_214, min_214};
main.c:69:5: note: transform reduction: created def-use cycle: vect_min_38.84_252 = PHI <vect_min_38.84_253(8), vect_cst__254(65)>
vect_min_38.84_253 = MIN_EXPR <vect__4.80_242, vect_min_38.84_252>;
main.c:69:5: note: Reduce using vector shifts
main.c:69:5: note: extract scalar result
main.c:69:5: note: ------>vectorizing statement: i_50 = i_134 + 1;
main.c:69:5: note: ------>vectorizing statement: vectp_arr.78_241 = vectp_arr.78_240 + 16;
main.c:69:5: note: ------>vectorizing statement: if (size_34(D) > i_50)

loop at main.c:70: if (ivtmp_262 < bnd.75_232)
main.c:69:5: note: LOOP VECTORIZED

main.c:61:6: note: vectorized 2 loops in function.
main.c:35:9: note: loop turned into non-loop; it never loops.
main.c:35:9: note: loop with 6 iterations completely unrolled
main.c:61:6: note: loop turned into non-loop; it never loops.
main.c:61:6: note: loop with 3 iterations completely unrolled
main.c:69:5: note: loop turned into non-loop; it never loops.
main.c:69:5: note: loop with 8 iterations completely unrolled
main.c:61:6: note: loop turned into non-loop; it never loops.
main.c:61:6: note: loop with 3 iterations completely unrolled
main.c:61:6: note: ===vect_slp_analyze_bb===
main.c:62:8: note: === vect_analyze_data_refs ===
main.c:62:8: note: not vectorized: not enough data-refs in basic block.
main.c:62:8: note: ===vect_slp_analyze_bb===
main.c:63:9: note: === vect_analyze_data_refs ===
main.c:63:9: note: got vectype for stmt: stderr.2_1 = stderr;
vector(2) long unsigned int
main.c:63:9: note: not vectorized: not enough data-refs in basic block.
main.c:64:9: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: max_37 = *arr_36(D);
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:34: note: === vect_analyze_data_refs ===
main.c:69:34: note: got vectype for stmt: _387 = *_386;
vector(4) int
main.c:69:34: note: not vectorized: not enough data-refs in basic block.
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:69:34: note: === vect_analyze_data_refs ===
main.c:69:34: note: got vectype for stmt: _398 = *_397;
vector(4) int
main.c:69:34: note: not vectorized: not enough data-refs in basic block.
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:69:34: note: === vect_analyze_data_refs ===
main.c:69:34: note: got vectype for stmt: _199 = *_198;
vector(4) int
main.c:69:34: note: not vectorized: not enough data-refs in basic block.
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:69:34: note: === vect_analyze_data_refs ===
main.c:69:34: note: not vectorized: not enough data-refs in basic block.
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:70:15: note: === vect_analyze_data_refs ===
main.c:70:15: note: not vectorized: no vectype for stmt: vect__4.80_242 = MEM[(int *)vectp_arr.78_240];
 scalar_type: vector(4) int
main.c:70:15: note: not vectorized: not enough data-refs in basic block.
main.c:70:15: note: ===vect_slp_analyze_bb===
main.c:70:15: note: ===vect_slp_analyze_bb===
main.c:70:15: note: ===vect_slp_analyze_bb===
main.c:70:15: note: === vect_analyze_data_refs ===
main.c:70:15: note: not vectorized: not enough data-refs in basic block.
main.c:70:15: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _323 = *_322;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _332 = *_331;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _341 = *_340;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _350 = *_349;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _359 = *_358;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _368 = *_367;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:5: note: === vect_analyze_data_refs ===
main.c:69:5: note: got vectype for stmt: _377 = *_376;
vector(4) int
main.c:69:5: note: not vectorized: not enough data-refs in basic block.
main.c:69:5: note: ===vect_slp_analyze_bb===
main.c:69:34: note: === vect_analyze_data_refs ===
main.c:69:34: note: got vectype for stmt: _222 = *_221;
vector(4) int
main.c:69:34: note: not vectorized: not enough data-refs in basic block.
main.c:69:34: note: ===vect_slp_analyze_bb===
main.c:16:24: note: === vect_analyze_data_refs ===
main.c:16:24: note: not vectorized: not enough data-refs in basic block.
main.c:16:24: note: ===vect_slp_analyze_bb===
main.c:79:5: note: === vect_analyze_data_refs ===
main.c:79:5: note: got vectype for stmt: block_arr_77->array = _79;
vector(2) long unsigned int
main.c:79:5: note: got vectype for stmt: block_arr_77->n_elem = 0;
vector(2) long unsigned int
main.c:79:5: note: got vectype for stmt: block_arr_77->max_elem = size_34(D);
vector(2) long unsigned int
main.c:79:5: note: got vectype for stmt: buckets[i_136] = block_arr_77;
vector(2) long unsigned int
main.c:79:5: note: === vect_analyze_data_ref_accesses ===
main.c:79:5: note: Detected interleaving store block_arr_77->n_elem and block_arr_77->max_elem
main.c:79:5: note: not consecutive access block_arr_77->array = _79;
main.c:79:5: note: Detected interleaving store of size 2 starting with block_arr_77->n_elem = 0;
main.c:79:5: note: === vect_pattern_recog ===
main.c:79:5: note: === vect_analyze_slp ===
main.c:79:5: note: Build SLP for block_arr_77->n_elem = 0;
main.c:79:5: note: Build SLP for block_arr_77->max_elem = size_34(D);
main.c:79:5: note: Build SLP failed: different operation in stmt block_arr_77->max_elem = size_34(D);
main.c:79:5: note: original stmt block_arr_77->n_elem = 0;
main.c:79:5: note: ===vect_slp_analyze_bb===
main.c:79:5: note: ===vect_slp_analyze_bb===
main.c:79:5: note: === vect_analyze_data_refs ===
main.c:79:5: note: not vectorized: not enough data-refs in basic block.
main.c:79:5: note: ===vect_slp_analyze_bb===
main.c:48:7: note: === vect_analyze_data_refs ===
main.c:48:7: note: got vectype for stmt: _8 = *_7;
vector(4) int
main.c:48:7: note: got vectype for stmt: _15 = buckets[n_bucket_44];
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: _80 = _15->n_elem;
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: _81 = _15->max_elem;
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: pretmp_159 = _15->array;
vector(2) long unsigned int
main.c:48:7: note: === vect_analyze_data_ref_accesses ===
main.c:48:7: note: Detected interleaving load _15->n_elem and _15->max_elem
main.c:48:7: note: not consecutive access _15 = buckets[n_bucket_44];
main.c:48:7: note: not consecutive access pretmp_159 = _15->array;
main.c:48:7: note: Detected interleaving load of size 2 starting with _80 = _15->n_elem;
main.c:48:7: note: not vectorized: no grouped stores in basic block.
main.c:48:7: note: ===vect_slp_analyze_bb===
main.c:49:22: note: === vect_analyze_data_refs ===
main.c:49:22: note: not vectorized: not enough data-refs in basic block.
main.c:50:23: note: === vect_analyze_data_refs ===
main.c:50:23: note: got vectype for stmt: _15->array = _84;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: _15->max_elem = _86;
vector(2) long unsigned int
main.c:50:23: note: === vect_analyze_data_ref_accesses ===
main.c:50:23: note: not consecutive access _15->array = _84;
main.c:50:23: note: not consecutive access _15->max_elem = _86;
main.c:50:23: note: not vectorized: no grouped stores in basic block.
main.c:50:23: note: ===vect_slp_analyze_bb===
main.c:82:5: note: === vect_analyze_data_refs ===
main.c:82:5: note: got vectype for stmt: *_90 = _8;
vector(4) int
main.c:82:5: note: got vectype for stmt: _15->n_elem = _91;
vector(2) long unsigned int
main.c:82:5: note: === vect_analyze_data_ref_accesses ===
main.c:82:5: note: not consecutive access *_90 = _8;
main.c:82:5: note: not consecutive access _15->n_elem = _91;
main.c:82:5: note: not vectorized: no grouped stores in basic block.
main.c:82:5: note: ===vect_slp_analyze_bb===
main.c:82:5: note: ===vect_slp_analyze_bb===
main.c:82:5: note: ===vect_slp_analyze_bb===
main.c:94:9: note: === vect_analyze_data_refs ===
main.c:94:9: note: got vectype for stmt: _16 = buckets[i_138];
vector(2) long unsigned int
main.c:94:9: note: got vectype for stmt: _17 = _16->n_elem;
vector(2) long unsigned int
main.c:94:9: note: got vectype for stmt: _19 = _16->array;
vector(2) long unsigned int
main.c:94:9: note: === vect_analyze_data_ref_accesses ===
main.c:94:9: note: not consecutive access _19 = _16->array;
main.c:94:9: note: not consecutive access _17 = _16->n_elem;
main.c:94:9: note: not vectorized: no grouped stores in basic block.
main.c:93:5: note: === vect_analyze_data_refs ===
main.c:93:5: note: not vectorized: not enough data-refs in basic block.
main.c:93:5: note: ===vect_slp_analyze_bb===
main.c:93:5: note: ===vect_slp_analyze_bb===
main.c:93:5: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: got vectype for stmt: _54 = _128->array;
vector(2) long unsigned int
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:35: note: === vect_analyze_data_refs ===
main.c:36:35: note: not vectorized: not enough data-refs in basic block.
main.c:36:35: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _301 = *_297;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_300 = _301;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_300 = _301;
main.c:36:22: note: not consecutive access _301 = *_297;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _314 = *_310;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_313 = _314;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_313 = _314;
main.c:36:22: note: not consecutive access _314 = *_310;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: got vectype for stmt: _55 = *_66;
vector(4) int
main.c:36:22: note: got vectype for stmt: *_58 = _55;
vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not consecutive access *_58 = _55;
main.c:36:22: note: not consecutive access _55 = *_66;
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: not enough data-refs in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: no vectype for stmt: vect__62.68_184 = MEM[(int *)vectp.66_182];
 scalar_type: vector(4) int
main.c:36:22: note: not vectorized: no vectype for stmt: MEM[(int *)vectp.69_188] = vect__62.68_184;
 scalar_type: vector(4) int
main.c:36:22: note: === vect_analyze_data_ref_accesses ===
main.c:36:22: note: not vectorized: no grouped stores in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:36:22: note: === vect_analyze_data_refs ===
main.c:36:22: note: not vectorized: not enough data-refs in basic block.
main.c:36:22: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _69 = *_227;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_27 = _69;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_27 = _69;
main.c:35:9: note: not consecutive access _69 = *_227;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _61 = *_56;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_60 = _61;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_60 = _61;
main.c:35:9: note: not consecutive access _61 = *_56;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _267 = *_263;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_266 = _267;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_266 = _267;
main.c:35:9: note: not consecutive access _267 = *_263;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _278 = *_274;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_277 = _278;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_277 = _278;
main.c:35:9: note: not consecutive access _278 = *_274;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _289 = *_285;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_288 = _289;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access *_288 = _289;
main.c:35:9: note: not consecutive access _289 = *_285;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:62: note: === vect_analyze_data_refs ===
main.c:35:62: note: got vectype for stmt: _150 = *_163;
vector(4) int
main.c:35:62: note: got vectype for stmt: *_151 = _150;
vector(4) int
main.c:35:62: note: === vect_analyze_data_ref_accesses ===
main.c:35:62: note: not consecutive access *_151 = _150;
main.c:35:62: note: not consecutive access _150 = *_163;
main.c:35:62: note: not vectorized: no grouped stores in basic block.
main.c:35:62: note: ===vect_slp_analyze_bb===
main.c:35:62: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _106 = *_111;
vector(4) int
main.c:35:9: note: got vectype for stmt: *_107 = _106;
vector(4) int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: not vectorized: not enough data-refs in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:31:5: note: === vect_analyze_data_refs ===
main.c:31:5: note: not vectorized: not enough data-refs in basic block.
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:31:5: note: ===vect_slp_analyze_bb===
main.c:35:9: note: === vect_analyze_data_refs ===
main.c:35:9: note: got vectype for stmt: _128 = *_127;
vector(2) long unsigned int
main.c:35:9: note: got vectype for stmt: _18 = _128->n_elem;
vector(2) long unsigned int
main.c:35:9: note: === vect_analyze_data_ref_accesses ===
main.c:35:9: note: not consecutive access _18 = _128->n_elem;
main.c:35:9: note: not vectorized: no grouped stores in basic block.
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:35:9: note: ===vect_slp_analyze_bb===
main.c:24:5: note: === vect_analyze_data_refs ===
main.c:24:5: note: got vectype for stmt: _20 = buckets[i_139];
vector(2) long unsigned int
main.c:24:5: note: got vectype for stmt: _71 = _20->array;
vector(2) long unsigned int
main.c:24:5: note: === vect_analyze_data_ref_accesses ===
main.c:24:5: note: not consecutive access _71 = _20->array;
main.c:24:5: note: not vectorized: no grouped stores in basic block.
main.c:98:5: note: === vect_analyze_data_refs ===
main.c:98:5: note: not vectorized: not enough data-refs in basic block.
main.c:98:5: note: ===vect_slp_analyze_bb===
main.c:98:5: note: ===vect_slp_analyze_bb===
main.c:101:1: note: === vect_analyze_data_refs ===
main.c:101:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:104
main.c:104:5: note: ===== analyze_loop_nest =====
main.c:104:5: note: === vect_analyze_loop_form ===
main.c:104:5: note: === get_loop_niters ===
main.c:104:5: note: Symbolic number of iterations is size_7(D)
main.c:104:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed
main.c:103:6: note: vectorized 0 loops in function.
main.c:103:6: note: ===vect_slp_analyze_bb===
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:106:9: note: === vect_analyze_data_refs ===
main.c:106:9: note: got vectype for stmt: _3 = *_2;
vector(4) int
main.c:106:9: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:108:1: note: === vect_analyze_data_refs ===
main.c:108:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:104
main.c:104:5: note: ===== analyze_loop_nest =====
main.c:104:5: note: === vect_analyze_loop_form ===
main.c:104:5: note: === get_loop_niters ===
main.c:104:5: note: Symbolic number of iterations is size_14
main.c:104:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:116
main.c:116:11: note: ===== analyze_loop_nest =====
main.c:116:11: note: === vect_analyze_loop_form ===
main.c:116:11: note: not vectorized: control flow in loop.
main.c:116:11: note: bad loop form.
main.c:111:5: note: vectorized 0 loops in function.
main.c:111:5: note: ===vect_slp_analyze_bb===
main.c:114:11: note: === vect_analyze_data_refs ===
main.c:114:11: note: got vectype for stmt: _1 = MEM[(char * *)argv_10(D) + 8B];
vector(2) long unsigned int
main.c:114:11: note: not vectorized: not enough data-refs in basic block.
main.c:114:11: note: ===vect_slp_analyze_bb===
main.c:48:7: note: === vect_analyze_data_refs ===
main.c:48:7: note: got vectype for stmt: v.3_2 = v;
vector(4) int
main.c:48:7: note: got vectype for stmt: _29 = b_9->n_elem;
vector(2) long unsigned int
main.c:48:7: note: got vectype for stmt: _30 = b_9->max_elem;
vector(2) long unsigned int
main.c:48:7: note: === vect_analyze_data_ref_accesses ===
main.c:48:7: note: Detected interleaving load b_9->n_elem and b_9->max_elem
main.c:48:7: note: not consecutive access v.3_2 = v;
main.c:48:7: note: Detected interleaving load of size 2 starting with _29 = b_9->n_elem;
main.c:48:7: note: not vectorized: no grouped stores in basic block.
main.c:48:7: note: ===vect_slp_analyze_bb===
main.c:48:7: note: === vect_analyze_data_refs ===
main.c:48:7: note: got vectype for stmt: pretmp_56 = b_9->array;
vector(2) long unsigned int
main.c:48:7: note: not vectorized: not enough data-refs in basic block.
main.c:48:7: note: ===vect_slp_analyze_bb===
main.c:49:22: note: === vect_analyze_data_refs ===
main.c:49:22: note: got vectype for stmt: _32 = b_9->array;
vector(2) long unsigned int
main.c:49:22: note: not vectorized: not enough data-refs in basic block.
main.c:50:23: note: === vect_analyze_data_refs ===
main.c:50:23: note: got vectype for stmt: b_9->array = _33;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: _34 = b_9->max_elem;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: b_9->max_elem = _35;
vector(2) long unsigned int
main.c:50:23: note: got vectype for stmt: pretmp_58 = b_9->n_elem;
vector(2) long unsigned int
main.c:50:23: note: === vect_analyze_data_ref_accesses ===
main.c:50:23: note: Detected interleaving load b_9->n_elem and b_9->max_elem
main.c:50:23: note: Detected interleaving load of size 2 starting with pretmp_58 = b_9->n_elem;
main.c:50:23: note: not consecutive access b_9->array = _33;
main.c:50:23: note: not consecutive access b_9->max_elem = _35;
main.c:50:23: note: not vectorized: no grouped stores in basic block.
main.c:50:23: note: ===vect_slp_analyze_bb===
main.c:53:16: note: === vect_analyze_data_refs ===
main.c:53:16: note: got vectype for stmt: *_39 = v.3_2;
vector(4) int
main.c:53:16: note: got vectype for stmt: b_9->n_elem = _40;
vector(2) long unsigned int
main.c:53:16: note: === vect_analyze_data_ref_accesses ===
main.c:53:16: note: not consecutive access *_39 = v.3_2;
main.c:53:16: note: not consecutive access b_9->n_elem = _40;
main.c:53:16: note: not vectorized: no grouped stores in basic block.
main.c:53:16: note: ===vect_slp_analyze_bb===
main.c:116:11: note: === vect_analyze_data_refs ===
main.c:116:11: note: not vectorized: not enough data-refs in basic block.
main.c:116:11: note: ===vect_slp_analyze_bb===
main.c:127:5: note: === vect_analyze_data_refs ===
main.c:127:5: note: got vectype for stmt: size_14 = b_9->n_elem;
vector(2) long unsigned int
main.c:127:5: note: got vectype for stmt: _4 = b_9->array;
vector(2) long unsigned int
main.c:127:5: note: === vect_analyze_data_ref_accesses ===
main.c:127:5: note: not consecutive access _4 = b_9->array;
main.c:127:5: note: not consecutive access size_14 = b_9->n_elem;
main.c:127:5: note: not vectorized: no grouped stores in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: got vectype for stmt: _5 = b_9->array;
vector(2) long unsigned int
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:106:9: note: === vect_analyze_data_refs ===
main.c:106:9: note: got vectype for stmt: _23 = *_22;
vector(4) int
main.c:106:9: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:24:5: note: === vect_analyze_data_refs ===
main.c:24:5: note: got vectype for stmt: _19 = b_9->array;
vector(2) long unsigned int
main.c:24:5: note: not vectorized: not enough data-refs in basic block.
main.c:111:5: note: === vect_analyze_data_refs ===
main.c:111:5: note: not vectorized: not enough data-refs in basic block.
