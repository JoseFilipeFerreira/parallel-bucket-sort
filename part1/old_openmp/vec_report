main.c:56:5: note: ===vect_slp_analyze_bb===
main.c:57:23: note: === vect_analyze_data_refs ===
main.c:57:23: note: got vectype for stmt: _1 = MEM[(int *)a_4(D)];
vector(4) int
main.c:57:23: note: got vectype for stmt: _2 = MEM[(int *)b_5(D)];
vector(4) int
main.c:57:23: note: === vect_analyze_data_ref_accesses ===
main.c:57:23: note: not consecutive access _1 = MEM[(int *)a_4(D)];
main.c:57:23: note: not consecutive access _2 = MEM[(int *)b_5(D)];
main.c:57:23: note: not vectorized: no grouped stores in basic block.
main.c:57:23: note: ===vect_slp_analyze_bb===
main.c:15:24: note: === vect_analyze_data_refs ===
main.c:15:24: note: not vectorized: not enough data-refs in basic block.
main.c:19:12: note: === vect_analyze_data_refs ===
main.c:19:12: note: got vectype for stmt: block_arr_5->array = _2;
vector(2) long unsigned int
main.c:19:12: note: got vectype for stmt: block_arr_5->n_elem = 0;
vector(2) long unsigned int
main.c:19:12: note: got vectype for stmt: block_arr_5->max_elem = max_6(D);
vector(2) long unsigned int
main.c:19:12: note: === vect_analyze_data_ref_accesses ===
main.c:19:12: note: Detected interleaving store block_arr_5->n_elem and block_arr_5->max_elem
main.c:19:12: note: not consecutive access block_arr_5->array = _2;
main.c:19:12: note: Detected interleaving store of size 2 starting with block_arr_5->n_elem = 0;
main.c:19:12: note: === vect_pattern_recog ===
main.c:19:12: note: === vect_analyze_slp ===
main.c:19:12: note: Build SLP for block_arr_5->n_elem = 0;
main.c:19:12: note: Build SLP for block_arr_5->max_elem = max_6(D);
main.c:19:12: note: Build SLP failed: different operation in stmt block_arr_5->max_elem = max_6(D);
main.c:19:12: note: original stmt block_arr_5->n_elem = 0;
main.c:19:12: note: ===vect_slp_analyze_bb===
main.c:23:5: note: === vect_analyze_data_refs ===
main.c:23:5: note: got vectype for stmt: _1 = b_3(D)->array;
vector(2) long unsigned int
main.c:23:5: note: not vectorized: not enough data-refs in basic block.
main.c:25:1: note: === vect_analyze_data_refs ===
main.c:25:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:30
main.c:30:5: note: ===== analyze_loop_nest =====
main.c:30:5: note: === vect_analyze_loop_form ===
main.c:30:5: note: not vectorized: control flow in loop.
main.c:30:5: note: bad loop form.

Analyzing loop at main.c:34
main.c:34:9: note: ===== analyze_loop_nest =====
main.c:34:9: note: === vect_analyze_loop_form ===
main.c:34:9: note: === get_loop_niters ===
main.c:34:9: note: Symbolic number of iterations is (size_t) _34
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _7 = *_4;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_6 = _7;
vector(4) int
main.c:34:9: note: === vect_analyze_scalar_cycles ===
main.c:34:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: Access function of PHI: {w_38, +, 1}_2
main.c:34:9: note: step: 1,  init: w_38
main.c:34:9: note: Detected induction.
main.c:34:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: Access function of PHI: {0, +, 1}_2
main.c:34:9: note: step: 1,  init: 0
main.c:34:9: note: Detected induction.
main.c:34:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: === vect_pattern_recog ===
main.c:34:9: note: vect_is_simple_use: operand elem_40
main.c:34:9: note: def_stmt: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: type of def: induction
main.c:34:9: note: vect_is_simple_use: operand w_36
main.c:34:9: note: def_stmt: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: type of def: induction
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: === vect_mark_stmts_to_be_vectorized ===
main.c:34:9: note: init: phi relevant? w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: init: phi relevant? elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: init: phi relevant? .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: init: stmt relevant? _3 = elem_40 * 4;
main.c:34:9: note: init: stmt relevant? _4 = _2 + _3;
main.c:34:9: note: init: stmt relevant? w_22 = w_36 + 1;
main.c:34:9: note: init: stmt relevant? _5 = w_36 * 4;
main.c:34:9: note: init: stmt relevant? _6 = res_23(D) + _5;
main.c:34:9: note: init: stmt relevant? _7 = *_4;
main.c:34:9: note: init: stmt relevant? *_6 = _7;
main.c:34:9: note: vec_stmt_relevant_p: stmt has vdefs.
main.c:34:9: note: mark relevant 5, live 0: *_6 = _7;
main.c:34:9: note: init: stmt relevant? elem_25 = elem_40 + 1;
main.c:34:9: note: init: stmt relevant? if (elem_25 < _34)
main.c:34:9: note: worklist: examine stmt: *_6 = _7;
main.c:34:9: note: vect_is_simple_use: operand _7
main.c:34:9: note: def_stmt: _7 = *_4;
main.c:34:9: note: type of def: internal
main.c:34:9: note: mark relevant 5, live 0: _7 = *_4;
main.c:34:9: note: worklist: examine stmt: _7 = *_4;
main.c:34:9: note: === vect_analyze_data_ref_dependences ===
main.c:34:9: note: versioning for alias required: can't determine dependence between *_4 and *_6
main.c:34:9: note: mark for run-time aliasing test between *_4 and *_6
main.c:34:9: note: === vect_determine_vectorization_factor ===
main.c:34:9: note: ==> examining phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: ==> examining phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: ==> examining phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: ==> examining statement: _3 = elem_40 * 4;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _4 = _2 + _3;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: w_22 = w_36 + 1;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _5 = w_36 * 4;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _6 = res_23(D) + _5;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _7 = *_4;
main.c:34:9: note: get vectype for scalar type:  int
main.c:34:9: note: vectype: vector(4) int
main.c:34:9: note: nunits = 4
main.c:34:9: note: ==> examining statement: *_6 = _7;
main.c:34:9: note: get vectype for scalar type:  int
main.c:34:9: note: vectype: vector(4) int
main.c:34:9: note: nunits = 4
main.c:34:9: note: ==> examining statement: elem_25 = elem_40 + 1;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: if (elem_25 < _34)
main.c:34:9: note: skip.
main.c:34:9: note: vectorization factor = 4
main.c:34:9: note: === vect_analyze_slp ===
main.c:34:9: note: === vect_make_slp_decision ===
main.c:34:9: note: === vect_analyze_data_refs_alignment ===
main.c:34:9: note: vect_compute_data_ref_alignment:
main.c:34:9: note: can't force alignment of ref: *_4
main.c:34:9: note: vect_compute_data_ref_alignment:
main.c:34:9: note: can't force alignment of ref: *_6
main.c:34:9: note: === vect_prune_runtime_alias_test_list ===
main.c:34:9: note: improved number of alias checks from 1 to 1
main.c:34:9: note: === vect_enhance_data_refs_alignment ===
main.c:34:9: note: Unknown misalignment, naturally aligned
main.c:34:9: note: Unknown misalignment, naturally aligned
main.c:34:9: note: vect_can_advance_ivs_p:
main.c:34:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: vect_model_load_cost: unaligned supported by hardware.
main.c:34:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:34:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:34:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:34:9: note: Setting misalignment to -1.
main.c:34:9: note: Setting misalignment to -1.
main.c:34:9: note: Alignment of access forced using peeling.
main.c:34:9: note: Peeling for alignment will be applied.
main.c:34:9: note: Vectorizing an unaligned access.
main.c:34:9: note: === vect_analyze_loop_operations ===
main.c:34:9: note: examining phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: examining phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: examining phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: ==> examining statement: _3 = elem_40 * 4;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _4 = _2 + _3;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: w_22 = w_36 + 1;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _5 = w_36 * 4;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _6 = res_23(D) + _5;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _7 = *_4;
main.c:34:9: note: vect_is_simple_use: operand *_4
main.c:34:9: note: not ssa-name.
main.c:34:9: note: use not simple.
main.c:34:9: note: vect_is_simple_use: operand *_4
main.c:34:9: note: not ssa-name.
main.c:34:9: note: use not simple.
main.c:34:9: note: vect_model_load_cost: aligned.
main.c:34:9: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:34:9: note: ==> examining statement: *_6 = _7;
main.c:34:9: note: vect_is_simple_use: operand _7
main.c:34:9: note: def_stmt: _7 = *_4;
main.c:34:9: note: type of def: internal
main.c:34:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:34:9: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
main.c:34:9: note: ==> examining statement: elem_25 = elem_40 + 1;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: if (elem_25 < _34)
main.c:34:9: note: irrelevant.
cost model: Adding cost of checks for loop versioning aliasing.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:34:9: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 8
  Scalar iteration cost: 2
  Scalar outside cost: 1
  Vector outside cost: 20
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 13
main.c:34:9: note:   Runtime profitability threshold = 12
main.c:34:9: note:   Static estimate profitability threshold = 13
main.c:34:9: note: epilog loop required
main.c:34:9: note: vect_can_advance_ivs_p:
main.c:34:9: note: Analyze phi: w_36 = PHI <w_22(6), w_38(4)>
main.c:34:9: note: Analyze phi: elem_40 = PHI <elem_25(6), 0(4)>
main.c:34:9: note: Analyze phi: .MEM_41 = PHI <.MEM_24(6), .MEM_44(4)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: loop vectorized
main.c:34:9: note: === vec_transform_loop ===
main.c:34:9: note: Profitability threshold is 12 loop iterations.
main.c:34:9: note: create runtime check for data references *_6 and *_4
main.c:34:9: note: created 1 versioning for alias checks.
main.c:34:9: note: loop versioned for vectorization because of possible aliasing
main.c:34:9: note: created _2
main.c:34:9: note: niters for prolog loop: (size_t) -((unsigned long) _2 >> 2) & 3

loop at main.c:35: if (ivtmp_73 < prolog_loop_niters.22_68)
main.c:34:9: note: === vect_update_inits_of_dr ===
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: w_36 = PHI <w_22(6), w_74(23)>
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: elem_40 = PHI <elem_25(6), elem_75(23)>
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: .MEM_41 = PHI <.MEM_24(6), .MEM_76(23)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: ------>vectorizing phi: w_36 = PHI <w_22(6), w_74(31)>
main.c:34:9: note: ------>vectorizing phi: elem_40 = PHI <elem_25(6), elem_75(31)>
main.c:34:9: note: ------>vectorizing phi: .MEM_41 = PHI <.MEM_24(6), .MEM_76(31)>
main.c:34:9: note: ------>vectorizing statement: _3 = elem_40 * 4;
main.c:34:9: note: ------>vectorizing statement: _4 = _2 + _3;
main.c:34:9: note: ------>vectorizing statement: w_22 = w_36 + 1;
main.c:34:9: note: ------>vectorizing statement: _5 = w_36 * 4;
main.c:34:9: note: ------>vectorizing statement: _6 = res_23(D) + _5;
main.c:34:9: note: ------>vectorizing statement: _7 = *_4;
main.c:34:9: note: transform statement.
main.c:34:9: note: transform load. ncopies = 1
main.c:34:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *_2
main.c:34:9: note: created vectp.29_100
main.c:34:9: note: add new stmt: vect__7.30_104 = MEM[(int *)vectp.28_102];
main.c:34:9: note: ------>vectorizing statement: *_6 = _7;
main.c:34:9: note: transform statement.
main.c:34:9: note: vect_is_simple_use: operand _7
main.c:34:9: note: def_stmt: _7 = *_4;
main.c:34:9: note: type of def: internal
main.c:34:9: note: transform store. ncopies = 1
main.c:34:9: note: vect_get_vec_def_for_operand: _7
main.c:34:9: note: vect_is_simple_use: operand _7
main.c:34:9: note: def_stmt: _7 = *_4;
main.c:34:9: note: type of def: internal
main.c:34:9: note:   def_stmt =  _7 = *_4;
main.c:34:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *res_23(D) + (sizetype) (w_38 * 4)
main.c:34:9: note: created vectp.32_105
main.c:34:9: note: add new stmt: MEM[(int *)vectp.31_108] = vect__7.30_104;
main.c:34:9: note: ------>vectorizing statement: elem_25 = elem_40 + 1;
main.c:34:9: note: ------>vectorizing statement: vectp.28_103 = vectp.28_102 + 16;
main.c:34:9: note: ------>vectorizing statement: vectp.31_109 = vectp.31_108 + 16;
main.c:34:9: note: ------>vectorizing statement: if (elem_25 < _34)

loop at main.c:35: if (ivtmp_112 < bnd.24_95)
main.c:34:9: note: LOOP VECTORIZED

main.c:28:6: note: vectorized 1 loops in function.
main.c:34:9: note: loop turned into non-loop; it never loops.
main.c:34:9: note: loop with 6 iterations completely unrolled
main.c:28:6: note: loop turned into non-loop; it never loops.
main.c:28:6: note: loop with 3 iterations completely unrolled
main.c:28:6: note: ===vect_slp_analyze_bb===
main.c:30:5: note: === vect_analyze_data_refs ===
main.c:30:5: note: not vectorized: not enough data-refs in basic block.
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: got vectype for stmt: _2 = _33->array;
vector(2) long unsigned int
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _164 = *_160;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_163 = _164;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_163 = _164;
main.c:35:22: note: not consecutive access _164 = *_160;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _177 = *_173;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_176 = _177;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_176 = _177;
main.c:35:22: note: not consecutive access _177 = *_173;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _62 = *_58;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_61 = _62;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_61 = _62;
main.c:35:22: note: not consecutive access _62 = *_58;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: not enough data-refs in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: no vectype for stmt: vect__7.30_104 = MEM[(int *)vectp.28_102];
 scalar_type: vector(4) int
main.c:35:22: note: not vectorized: no vectype for stmt: MEM[(int *)vectp.31_108] = vect__7.30_104;
 scalar_type: vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: not enough data-refs in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _6 = *_3;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_5 = _6;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_5 = _6;
main.c:34:9: note: not consecutive access _6 = *_3;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _119 = *_115;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_118 = _119;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_118 = _119;
main.c:34:9: note: not consecutive access _119 = *_115;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _130 = *_126;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_129 = _130;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_129 = _130;
main.c:34:9: note: not consecutive access _130 = *_126;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _141 = *_137;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_140 = _141;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_140 = _141;
main.c:34:9: note: not consecutive access _141 = *_137;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _152 = *_148;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_151 = _152;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_151 = _152;
main.c:34:9: note: not consecutive access _152 = *_148;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:62: note: === vect_analyze_data_refs ===
main.c:34:62: note: got vectype for stmt: _86 = *_82;
vector(4) int
main.c:34:62: note: got vectype for stmt: *_85 = _86;
vector(4) int
main.c:34:62: note: === vect_analyze_data_ref_accesses ===
main.c:34:62: note: not consecutive access *_85 = _86;
main.c:34:62: note: not consecutive access _86 = *_82;
main.c:34:62: note: not vectorized: no grouped stores in basic block.
main.c:34:62: note: ===vect_slp_analyze_bb===
main.c:34:62: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _48 = *_17;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_12 = _48;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: not vectorized: not enough data-refs in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:30:5: note: === vect_analyze_data_refs ===
main.c:30:5: note: not vectorized: not enough data-refs in basic block.
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _33 = *_32;
vector(2) long unsigned int
main.c:34:9: note: got vectype for stmt: _34 = _33->n_elem;
vector(2) long unsigned int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access _34 = _33->n_elem;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:44:1: note: === vect_analyze_data_refs ===
main.c:44:1: note: not vectorized: not enough data-refs in basic block.
main.c:44:1: note: ===vect_slp_analyze_bb===
main.c:47:7: note: === vect_analyze_data_refs ===
main.c:47:7: note: got vectype for stmt: _1 = arr_15(D)->n_elem;
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: _2 = arr_15(D)->max_elem;
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: pretmp_25 = arr_15(D)->array;
vector(2) long unsigned int
main.c:47:7: note: === vect_analyze_data_ref_accesses ===
main.c:47:7: note: Detected interleaving load arr_15(D)->n_elem and arr_15(D)->max_elem
main.c:47:7: note: not consecutive access pretmp_25 = arr_15(D)->array;
main.c:47:7: note: Detected interleaving load of size 2 starting with _1 = arr_15(D)->n_elem;
main.c:47:7: note: not vectorized: no grouped stores in basic block.
main.c:47:7: note: ===vect_slp_analyze_bb===
main.c:47:7: note: ===vect_slp_analyze_bb===
main.c:48:22: note: === vect_analyze_data_refs ===
main.c:48:22: note: not vectorized: not enough data-refs in basic block.
main.c:49:23: note: === vect_analyze_data_refs ===
main.c:49:23: note: got vectype for stmt: arr_15(D)->array = _5;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: _6 = arr_15(D)->max_elem;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: arr_15(D)->max_elem = _7;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: pretmp_27 = arr_15(D)->n_elem;
vector(2) long unsigned int
main.c:49:23: note: === vect_analyze_data_ref_accesses ===
main.c:49:23: note: Detected interleaving load arr_15(D)->n_elem and arr_15(D)->max_elem
main.c:49:23: note: Detected interleaving load of size 2 starting with pretmp_27 = arr_15(D)->n_elem;
main.c:49:23: note: not consecutive access arr_15(D)->array = _5;
main.c:49:23: note: not consecutive access arr_15(D)->max_elem = _7;
main.c:49:23: note: not vectorized: no grouped stores in basic block.
main.c:49:23: note: ===vect_slp_analyze_bb===
main.c:53:1: note: === vect_analyze_data_refs ===
main.c:53:1: note: got vectype for stmt: *_11 = elem_19(D);
vector(4) int
main.c:53:1: note: got vectype for stmt: arr_15(D)->n_elem = _12;
vector(2) long unsigned int
main.c:53:1: note: === vect_analyze_data_ref_accesses ===
main.c:53:1: note: not consecutive access *_11 = elem_19(D);
main.c:53:1: note: not consecutive access arr_15(D)->n_elem = _12;
main.c:53:1: note: not vectorized: no grouped stores in basic block.

Analyzing loop at main.c:98
main.c:98:5: note: ===== analyze_loop_nest =====
main.c:98:5: note: === vect_analyze_loop_form ===
main.c:98:5: note: === get_loop_niters ===
main.c:98:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:30
main.c:30:5: note: ===== analyze_loop_nest =====
main.c:30:5: note: === vect_analyze_loop_form ===
main.c:30:5: note: not vectorized: control flow in loop.
main.c:30:5: note: bad loop form.

Analyzing loop at main.c:34
main.c:34:9: note: ===== analyze_loop_nest =====
main.c:34:9: note: === vect_analyze_loop_form ===
main.c:34:9: note: === get_loop_niters ===
main.c:34:9: note: Symbolic number of iterations is _18
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _63 = *_58;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_62 = _63;
vector(4) int
main.c:34:9: note: === vect_analyze_scalar_cycles ===
main.c:34:9: note: Analyze phi: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: Access function of PHI: {0, +, 1}_7
main.c:34:9: note: step: 1,  init: 0
main.c:34:9: note: Detected induction.
main.c:34:9: note: Analyze phi: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: Access function of PHI: {w_147, +, 1}_7
main.c:34:9: note: step: 1,  init: w_147
main.c:34:9: note: Detected induction.
main.c:34:9: note: Analyze phi: .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: === vect_pattern_recog ===
main.c:34:9: note: vect_is_simple_use: operand elem_135
main.c:34:9: note: def_stmt: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: type of def: induction
main.c:34:9: note: vect_is_simple_use: operand w_133
main.c:34:9: note: def_stmt: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: type of def: induction
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: === vect_mark_stmts_to_be_vectorized ===
main.c:34:9: note: init: phi relevant? elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: init: phi relevant? w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: init: phi relevant? .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: init: stmt relevant? _57 = elem_135 * 4;
main.c:34:9: note: init: stmt relevant? _58 = _55 + _57;
main.c:34:9: note: init: stmt relevant? w_60 = w_133 + 1;
main.c:34:9: note: init: stmt relevant? _61 = w_133 * 4;
main.c:34:9: note: init: stmt relevant? _62 = arr_37(D) + _61;
main.c:34:9: note: init: stmt relevant? _63 = *_58;
main.c:34:9: note: init: stmt relevant? *_62 = _63;
main.c:34:9: note: vec_stmt_relevant_p: stmt has vdefs.
main.c:34:9: note: mark relevant 5, live 0: *_62 = _63;
main.c:34:9: note: init: stmt relevant? elem_64 = elem_135 + 1;
main.c:34:9: note: init: stmt relevant? if (_18 > elem_64)
main.c:34:9: note: worklist: examine stmt: *_62 = _63;
main.c:34:9: note: vect_is_simple_use: operand _63
main.c:34:9: note: def_stmt: _63 = *_58;
main.c:34:9: note: type of def: internal
main.c:34:9: note: mark relevant 5, live 0: _63 = *_58;
main.c:34:9: note: worklist: examine stmt: _63 = *_58;
main.c:34:9: note: === vect_analyze_data_ref_dependences ===
main.c:34:9: note: versioning for alias required: can't determine dependence between *_58 and *_62
main.c:34:9: note: mark for run-time aliasing test between *_58 and *_62
main.c:34:9: note: === vect_determine_vectorization_factor ===
main.c:34:9: note: ==> examining phi: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: ==> examining phi: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: ==> examining phi: .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: ==> examining statement: _57 = elem_135 * 4;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _58 = _55 + _57;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: w_60 = w_133 + 1;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _61 = w_133 * 4;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _62 = arr_37(D) + _61;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: _63 = *_58;
main.c:34:9: note: get vectype for scalar type:  int
main.c:34:9: note: vectype: vector(4) int
main.c:34:9: note: nunits = 4
main.c:34:9: note: ==> examining statement: *_62 = _63;
main.c:34:9: note: get vectype for scalar type:  int
main.c:34:9: note: vectype: vector(4) int
main.c:34:9: note: nunits = 4
main.c:34:9: note: ==> examining statement: elem_64 = elem_135 + 1;
main.c:34:9: note: skip.
main.c:34:9: note: ==> examining statement: if (_18 > elem_64)
main.c:34:9: note: skip.
main.c:34:9: note: vectorization factor = 4
main.c:34:9: note: === vect_analyze_slp ===
main.c:34:9: note: === vect_make_slp_decision ===
main.c:34:9: note: === vect_analyze_data_refs_alignment ===
main.c:34:9: note: vect_compute_data_ref_alignment:
main.c:34:9: note: can't force alignment of ref: *_58
main.c:34:9: note: vect_compute_data_ref_alignment:
main.c:34:9: note: can't force alignment of ref: *_62
main.c:34:9: note: === vect_prune_runtime_alias_test_list ===
main.c:34:9: note: improved number of alias checks from 1 to 1
main.c:34:9: note: === vect_enhance_data_refs_alignment ===
main.c:34:9: note: Unknown misalignment, naturally aligned
main.c:34:9: note: Unknown misalignment, naturally aligned
main.c:34:9: note: vect_can_advance_ivs_p:
main.c:34:9: note: Analyze phi: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: Analyze phi: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: Analyze phi: .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: vect_model_load_cost: unaligned supported by hardware.
main.c:34:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:34:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:34:9: note: vect_get_data_access_cost: inside_cost = 2, outside_cost = 0.
main.c:34:9: note: Setting misalignment to -1.
main.c:34:9: note: Setting misalignment to -1.
main.c:34:9: note: Alignment of access forced using peeling.
main.c:34:9: note: Peeling for alignment will be applied.
main.c:34:9: note: Vectorizing an unaligned access.
main.c:34:9: note: === vect_analyze_loop_operations ===
main.c:34:9: note: examining phi: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: examining phi: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: examining phi: .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: ==> examining statement: _57 = elem_135 * 4;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _58 = _55 + _57;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: w_60 = w_133 + 1;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _61 = w_133 * 4;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _62 = arr_37(D) + _61;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: _63 = *_58;
main.c:34:9: note: vect_is_simple_use: operand *_58
main.c:34:9: note: not ssa-name.
main.c:34:9: note: use not simple.
main.c:34:9: note: vect_is_simple_use: operand *_58
main.c:34:9: note: not ssa-name.
main.c:34:9: note: use not simple.
main.c:34:9: note: vect_model_load_cost: aligned.
main.c:34:9: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:34:9: note: ==> examining statement: *_62 = _63;
main.c:34:9: note: vect_is_simple_use: operand _63
main.c:34:9: note: def_stmt: _63 = *_58;
main.c:34:9: note: type of def: internal
main.c:34:9: note: vect_model_store_cost: unaligned supported by hardware.
main.c:34:9: note: vect_model_store_cost: inside_cost = 2, prologue_cost = 0 .
main.c:34:9: note: ==> examining statement: elem_64 = elem_135 + 1;
main.c:34:9: note: irrelevant.
main.c:34:9: note: ==> examining statement: if (_18 > elem_64)
main.c:34:9: note: irrelevant.
cost model: Adding cost of checks for loop versioning aliasing.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:34:9: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 8
  Scalar iteration cost: 2
  Scalar outside cost: 1
  Vector outside cost: 20
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 13
main.c:34:9: note:   Runtime profitability threshold = 12
main.c:34:9: note:   Static estimate profitability threshold = 13
main.c:34:9: note: epilog loop required
main.c:34:9: note: vect_can_advance_ivs_p:
main.c:34:9: note: Analyze phi: elem_135 = PHI <elem_64(25), 0(23)>
main.c:34:9: note: Analyze phi: w_133 = PHI <w_60(25), w_147(23)>
main.c:34:9: note: Analyze phi: .MEM_128 = PHI <.MEM_77(25), .MEM_148(23)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: loop vectorized
main.c:34:9: note: === vec_transform_loop ===
main.c:34:9: note: Profitability threshold is 12 loop iterations.
main.c:34:9: note: create runtime check for data references *_62 and *_58
main.c:34:9: note: created 1 versioning for alias checks.
main.c:34:9: note: loop versioned for vectorization because of possible aliasing
main.c:34:9: note: created _55
main.c:34:9: note: niters for prolog loop: (long unsigned int) -((unsigned long) _55 >> 2) & 3

loop at main.c:35: if (ivtmp_21 < prolog_loop_niters.60_29)
main.c:34:9: note: === vect_update_inits_of_dr ===
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: elem_135 = PHI <elem_64(25), elem_5(45)>
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: w_133 = PHI <w_60(25), w_174(45)>
main.c:34:9: note: vect_update_ivs_after_vectorizer: phi: .MEM_128 = PHI <.MEM_77(25), .MEM_170(45)>
main.c:34:9: note: reduc or virtual phi. skip.
main.c:34:9: note: ------>vectorizing phi: elem_135 = PHI <elem_64(25), elem_5(53)>
main.c:34:9: note: ------>vectorizing phi: w_133 = PHI <w_60(25), w_174(53)>
main.c:34:9: note: ------>vectorizing phi: .MEM_128 = PHI <.MEM_77(25), .MEM_170(53)>
main.c:34:9: note: ------>vectorizing statement: _57 = elem_135 * 4;
main.c:34:9: note: ------>vectorizing statement: _58 = _55 + _57;
main.c:34:9: note: ------>vectorizing statement: w_60 = w_133 + 1;
main.c:34:9: note: ------>vectorizing statement: _61 = w_133 * 4;
main.c:34:9: note: ------>vectorizing statement: _62 = arr_37(D) + _61;
main.c:34:9: note: ------>vectorizing statement: _63 = *_58;
main.c:34:9: note: transform statement.
main.c:34:9: note: transform load. ncopies = 1
main.c:34:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *_55
main.c:34:9: note: created vectp.67_181
main.c:34:9: note: add new stmt: vect__63.68_185 = MEM[(int *)vectp.66_183];
main.c:34:9: note: ------>vectorizing statement: *_62 = _63;
main.c:34:9: note: transform statement.
main.c:34:9: note: vect_is_simple_use: operand _63
main.c:34:9: note: def_stmt: _63 = *_58;
main.c:34:9: note: type of def: internal
main.c:34:9: note: transform store. ncopies = 1
main.c:34:9: note: vect_get_vec_def_for_operand: _63
main.c:34:9: note: vect_is_simple_use: operand _63
main.c:34:9: note: def_stmt: _63 = *_58;
main.c:34:9: note: type of def: internal
main.c:34:9: note:   def_stmt =  _63 = *_58;
main.c:34:9: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *arr_37(D) + (sizetype) (w_147 * 4)
main.c:34:9: note: created vectp.70_186
main.c:34:9: note: add new stmt: MEM[(int *)vectp.69_189] = vect__63.68_185;
main.c:34:9: note: ------>vectorizing statement: elem_64 = elem_135 + 1;
main.c:34:9: note: ------>vectorizing statement: vectp.66_184 = vectp.66_183 + 16;
main.c:34:9: note: ------>vectorizing statement: vectp.69_190 = vectp.69_189 + 16;
main.c:34:9: note: ------>vectorizing statement: if (_18 > elem_64)

loop at main.c:35: if (ivtmp_193 < bnd.62_176)
main.c:34:9: note: LOOP VECTORIZED


Analyzing loop at main.c:92
main.c:92:5: note: ===== analyze_loop_nest =====
main.c:92:5: note: === vect_analyze_loop_form ===
main.c:92:5: note: not vectorized: control flow in loop.
main.c:92:5: note: bad loop form.

Analyzing loop at main.c:81
main.c:81:5: note: ===== analyze_loop_nest =====
main.c:81:5: note: === vect_analyze_loop_form ===
main.c:81:5: note: not vectorized: control flow in loop.
main.c:81:5: note: bad loop form.

Analyzing loop at main.c:78
main.c:78:5: note: ===== analyze_loop_nest =====
main.c:78:5: note: === vect_analyze_loop_form ===
main.c:78:5: note: === get_loop_niters ===
main.c:78:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:68
main.c:68:5: note: ===== analyze_loop_nest =====
main.c:68:5: note: === vect_analyze_loop_form ===
main.c:68:5: note: === get_loop_niters ===
main.c:68:5: note: Symbolic number of iterations is size_35(D) + 18446744073709551615
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _4 = *_3;
vector(4) int
main.c:68:5: note: === vect_analyze_scalar_cycles ===
main.c:68:5: note: Analyze phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: Access function of PHI: max_70
main.c:68:5: note: Analyze phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: Access function of PHI: min_27
main.c:68:5: note: Analyze phi: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: Access function of PHI: {1, +, 1}_1
main.c:68:5: note: step: 1,  init: 1
main.c:68:5: note: Detected induction.
main.c:68:5: note: Analyze phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: detected reduction: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: Detected reduction.
main.c:68:5: note: Analyze phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: detected reduction: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: Detected reduction.
main.c:68:5: note: === vect_pattern_recog ===
main.c:68:5: note: vect_is_simple_use: operand i_136
main.c:68:5: note: def_stmt: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: type of def: induction
main.c:68:5: note: === vect_analyze_data_ref_accesses ===
main.c:68:5: note: === vect_mark_stmts_to_be_vectorized ===
main.c:68:5: note: init: phi relevant? max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: init: phi relevant? min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: init: phi relevant? i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: init: stmt relevant? _2 = i_136 * 4;
main.c:68:5: note: init: stmt relevant? _3 = arr_37(D) + _2;
main.c:68:5: note: init: stmt relevant? _4 = *_3;
main.c:68:5: note: init: stmt relevant? max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: vec_stmt_relevant_p: used out of loop.
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vec_stmt_relevant_p: stmt live but not relevant.
main.c:68:5: note: mark relevant 1, live 1: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: init: stmt relevant? min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: vec_stmt_relevant_p: used out of loop.
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vec_stmt_relevant_p: stmt live but not relevant.
main.c:68:5: note: mark relevant 1, live 1: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: init: stmt relevant? i_51 = i_136 + 1;
main.c:68:5: note: init: stmt relevant? if (size_35(D) > i_51)
main.c:68:5: note: worklist: examine stmt: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: mark relevant 1, live 0: _4 = *_3;
main.c:68:5: note: vect_is_simple_use: operand min_27
main.c:68:5: note: def_stmt: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: mark relevant 1, live 0: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: worklist: examine stmt: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: vect_is_simple_use: operand min_39
main.c:68:5: note: def_stmt: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: type of def: reduction
main.c:68:5: note: reduc-stmt defining reduc-phi in the same nest.
main.c:68:5: note: vect_is_simple_use: operand max_38
main.c:68:5: note: def_stmt: max_38 = *arr_37(D);
main.c:68:5: note: type of def: external
main.c:68:5: note: def_stmt is out of loop.
main.c:68:5: note: worklist: examine stmt: _4 = *_3;
main.c:68:5: note: worklist: examine stmt: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: mark relevant 1, live 0: _4 = *_3;
main.c:68:5: note: already marked relevant/live.
main.c:68:5: note: vect_is_simple_use: operand max_70
main.c:68:5: note: def_stmt: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: mark relevant 1, live 0: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: worklist: examine stmt: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: vect_is_simple_use: operand max_71
main.c:68:5: note: def_stmt: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: type of def: reduction
main.c:68:5: note: reduc-stmt defining reduc-phi in the same nest.
main.c:68:5: note: vect_is_simple_use: operand max_38
main.c:68:5: note: def_stmt: max_38 = *arr_37(D);
main.c:68:5: note: type of def: external
main.c:68:5: note: def_stmt is out of loop.
main.c:68:5: note: === vect_analyze_data_ref_dependences ===
main.c:68:5: note: === vect_determine_vectorization_factor ===
main.c:68:5: note: ==> examining phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: nunits = 4
main.c:68:5: note: ==> examining phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: nunits = 4
main.c:68:5: note: ==> examining phi: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: ==> examining statement: _2 = i_136 * 4;
main.c:68:5: note: skip.
main.c:68:5: note: ==> examining statement: _3 = arr_37(D) + _2;
main.c:68:5: note: skip.
main.c:68:5: note: ==> examining statement: _4 = *_3;
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: nunits = 4
main.c:68:5: note: ==> examining statement: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: nunits = 4
main.c:68:5: note: ==> examining statement: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: get vectype for scalar type:  int
main.c:68:5: note: vectype: vector(4) int
main.c:68:5: note: nunits = 4
main.c:68:5: note: ==> examining statement: i_51 = i_136 + 1;
main.c:68:5: note: skip.
main.c:68:5: note: ==> examining statement: if (size_35(D) > i_51)
main.c:68:5: note: skip.
main.c:68:5: note: vectorization factor = 4
main.c:68:5: note: === vect_analyze_slp ===
main.c:68:5: note: Build SLP for min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: Build SLP for max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: Build SLP failed: different operation in stmt max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: original stmt min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: === vect_make_slp_decision ===
main.c:68:5: note: === vect_analyze_data_refs_alignment ===
main.c:68:5: note: vect_compute_data_ref_alignment:
main.c:68:5: note: can't force alignment of ref: *_3
main.c:68:5: note: === vect_prune_runtime_alias_test_list ===
main.c:68:5: note: === vect_enhance_data_refs_alignment ===
main.c:68:5: note: Unknown misalignment, naturally aligned
main.c:68:5: note: vect_can_advance_ivs_p:
main.c:68:5: note: Analyze phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: Analyze phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: Analyze phi: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: Alignment of access forced using peeling.
main.c:68:5: note: Peeling for alignment will be applied.
main.c:68:5: note: === vect_analyze_loop_operations ===
main.c:68:5: note: examining phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: examining phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: examining phi: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: ==> examining statement: _2 = i_136 * 4;
main.c:68:5: note: irrelevant.
main.c:68:5: note: ==> examining statement: _3 = arr_37(D) + _2;
main.c:68:5: note: irrelevant.
main.c:68:5: note: ==> examining statement: _4 = *_3;
main.c:68:5: note: vect_is_simple_use: operand *_3
main.c:68:5: note: not ssa-name.
main.c:68:5: note: use not simple.
main.c:68:5: note: vect_is_simple_use: operand *_3
main.c:68:5: note: not ssa-name.
main.c:68:5: note: use not simple.
main.c:68:5: note: vect_model_load_cost: aligned.
main.c:68:5: note: vect_model_load_cost: inside_cost = 1, prologue_cost = 0 .
main.c:68:5: note: ==> examining statement: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vect_is_simple_use: operand max_70
main.c:68:5: note: def_stmt: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: detected reduction: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 1, prologue_cost = 1, epilogue_cost = 5 .
main.c:68:5: note: ==> examining statement: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vect_is_simple_use: operand min_27
main.c:68:5: note: def_stmt: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: detected reduction: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: reduc op not supported by target.
vect_model_reduction_cost: inside_cost = 1, prologue_cost = 1, epilogue_cost = 5 .
main.c:68:5: note: ==> examining statement: i_51 = i_136 + 1;
main.c:68:5: note: irrelevant.
main.c:68:5: note: ==> examining statement: if (size_35(D) > i_51)
main.c:68:5: note: irrelevant.
cost model: prologue peel iters set to vf/2.
cost model: epilogue peel iters set to vf/2 because peeling for alignment is unknown.
main.c:68:5: note: Cost model analysis: 
  Vector inside of loop cost: 3
  Vector prologue cost: 12
  Vector epilogue cost: 20
  Scalar iteration cost: 3
  Scalar outside cost: 7
  Vector outside cost: 32
  prologue iterations: 2
  epilogue iterations: 2
  Calculated minimum iters for profitability: 10
main.c:68:5: note:   Runtime profitability threshold = 9
main.c:68:5: note:   Static estimate profitability threshold = 15
main.c:68:5: note: epilog loop required
main.c:68:5: note: vect_can_advance_ivs_p:
main.c:68:5: note: Analyze phi: max_70 = PHI <max_71(8), max_38(5)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: Analyze phi: min_27 = PHI <min_39(8), max_38(5)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: Analyze phi: i_136 = PHI <i_51(8), 1(5)>
main.c:68:5: note: loop vectorized
main.c:68:5: note: === vec_transform_loop ===
main.c:68:5: note: Profitability threshold is 9 loop iterations.
main.c:68:5: note: created vectp_arr.72_207
main.c:68:5: note: niters for prolog loop: (size_t) -((unsigned long) vectp_arr.72_207 >> 2) & 3

loop at main.c:69: if (ivtmp_213 < prolog_loop_niters.73_208)
main.c:68:5: note: === vect_update_inits_of_dr ===
main.c:68:5: note: vect_update_ivs_after_vectorizer: phi: max_70 = PHI <max_71(8), max_214(59)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: vect_update_ivs_after_vectorizer: phi: min_27 = PHI <min_39(8), min_215(59)>
main.c:68:5: note: reduc or virtual phi. skip.
main.c:68:5: note: vect_update_ivs_after_vectorizer: phi: i_136 = PHI <i_51(8), i_216(59)>
main.c:68:5: note: ------>vectorizing phi: max_70 = PHI <max_71(8), max_214(67)>
main.c:68:5: note: ------>vectorizing phi: min_27 = PHI <min_39(8), min_215(67)>
main.c:68:5: note: ------>vectorizing phi: i_136 = PHI <i_51(8), i_216(67)>
main.c:68:5: note: ------>vectorizing statement: _2 = i_136 * 4;
main.c:68:5: note: ------>vectorizing statement: _3 = arr_37(D) + _2;
main.c:68:5: note: ------>vectorizing statement: _4 = *_3;
main.c:68:5: note: transform statement.
main.c:68:5: note: transform load. ncopies = 1
main.c:68:5: note: create vector_type-pointer variable to type: vector(4) int  vectorizing a pointer ref: *arr_37(D)
main.c:68:5: note: created vectp_arr.79_238
main.c:68:5: note: add new stmt: vect__4.80_243 = MEM[(int *)vectp_arr.78_241];
main.c:68:5: note: ------>vectorizing statement: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: transform statement.
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vect_is_simple_use: operand max_70
main.c:68:5: note: def_stmt: max_70 = PHI <max_71(8), max_214(67)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: detected reduction: max_71 = MAX_EXPR <_4, max_70>;
main.c:68:5: note: reduc op not supported by target.
main.c:68:5: note: transform reduction.
main.c:68:5: note: vect_get_vec_def_for_operand: _4
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note:   def_stmt =  _4 = *_3;
main.c:68:5: note: add new stmt: vect_max_71.81_245 = MAX_EXPR <vect__4.80_243, vect_max_71.81_244>;
main.c:68:5: note: vect_is_simple_use: operand max_214
main.c:68:5: note: def_stmt: max_214 = PHI <max_204(55), max_38(54)>
main.c:68:5: note: type of def: external
main.c:68:5: note: vect_get_vec_def_for_operand: max_214
main.c:68:5: note: vect_is_simple_use: operand max_214
main.c:68:5: note: def_stmt: max_214 = PHI <max_204(55), max_38(54)>
main.c:68:5: note: type of def: external
main.c:68:5: note:   def_stmt =  max_214 = PHI <max_204(55), max_38(54)>
main.c:68:5: note: created new init_stmt: vect_cst__246 = {max_214, max_214, max_214, max_214};
main.c:68:5: note: transform reduction: created def-use cycle: vect_max_71.81_244 = PHI <vect_max_71.81_245(8), vect_cst__246(67)>
vect_max_71.81_245 = MAX_EXPR <vect__4.80_243, vect_max_71.81_244>;
main.c:68:5: note: Reduce using vector shifts
main.c:68:5: note: extract scalar result
main.c:68:5: note: ------>vectorizing statement: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: transform statement.
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note: vect_is_simple_use: operand min_27
main.c:68:5: note: def_stmt: min_27 = PHI <min_39(8), min_215(67)>
main.c:68:5: note: type of def: reduction
main.c:68:5: note: detected reduction: min_39 = MIN_EXPR <_4, min_27>;
main.c:68:5: note: reduc op not supported by target.
main.c:68:5: note: transform reduction.
main.c:68:5: note: vect_get_vec_def_for_operand: _4
main.c:68:5: note: vect_is_simple_use: operand _4
main.c:68:5: note: def_stmt: _4 = *_3;
main.c:68:5: note: type of def: internal
main.c:68:5: note:   def_stmt =  _4 = *_3;
main.c:68:5: note: add new stmt: vect_min_39.84_254 = MIN_EXPR <vect__4.80_243, vect_min_39.84_253>;
main.c:68:5: note: vect_is_simple_use: operand min_215
main.c:68:5: note: def_stmt: min_215 = PHI <min_205(55), max_38(54)>
main.c:68:5: note: type of def: external
main.c:68:5: note: vect_get_vec_def_for_operand: min_215
main.c:68:5: note: vect_is_simple_use: operand min_215
main.c:68:5: note: def_stmt: min_215 = PHI <min_205(55), max_38(54)>
main.c:68:5: note: type of def: external
main.c:68:5: note:   def_stmt =  min_215 = PHI <min_205(55), max_38(54)>
main.c:68:5: note: created new init_stmt: vect_cst__255 = {min_215, min_215, min_215, min_215};
main.c:68:5: note: transform reduction: created def-use cycle: vect_min_39.84_253 = PHI <vect_min_39.84_254(8), vect_cst__255(67)>
vect_min_39.84_254 = MIN_EXPR <vect__4.80_243, vect_min_39.84_253>;
main.c:68:5: note: Reduce using vector shifts
main.c:68:5: note: extract scalar result
main.c:68:5: note: ------>vectorizing statement: i_51 = i_136 + 1;
main.c:68:5: note: ------>vectorizing statement: vectp_arr.78_242 = vectp_arr.78_241 + 16;
main.c:68:5: note: ------>vectorizing statement: if (size_35(D) > i_51)

loop at main.c:69: if (ivtmp_263 < bnd.75_233)
main.c:68:5: note: LOOP VECTORIZED

main.c:60:6: note: vectorized 2 loops in function.
main.c:34:9: note: loop turned into non-loop; it never loops.
main.c:34:9: note: loop with 6 iterations completely unrolled
main.c:60:6: note: loop turned into non-loop; it never loops.
main.c:60:6: note: loop with 3 iterations completely unrolled
main.c:92:5: note: loop turned into non-loop; it never loops.
main.c:92:5: note: loop with 10 iterations completely unrolled
main.c:68:5: note: loop turned into non-loop; it never loops.
main.c:68:5: note: loop with 8 iterations completely unrolled
main.c:60:6: note: loop turned into non-loop; it never loops.
main.c:60:6: note: loop with 3 iterations completely unrolled
main.c:60:6: note: ===vect_slp_analyze_bb===
main.c:61:8: note: === vect_analyze_data_refs ===
main.c:61:8: note: not vectorized: not enough data-refs in basic block.
main.c:61:8: note: ===vect_slp_analyze_bb===
main.c:62:9: note: === vect_analyze_data_refs ===
main.c:62:9: note: got vectype for stmt: stderr.2_1 = stderr;
vector(2) long unsigned int
main.c:62:9: note: not vectorized: not enough data-refs in basic block.
main.c:63:9: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: max_38 = *arr_37(D);
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:34: note: === vect_analyze_data_refs ===
main.c:68:34: note: got vectype for stmt: _478 = *_477;
vector(4) int
main.c:68:34: note: not vectorized: not enough data-refs in basic block.
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:68:34: note: === vect_analyze_data_refs ===
main.c:68:34: note: got vectype for stmt: _489 = *_488;
vector(4) int
main.c:68:34: note: not vectorized: not enough data-refs in basic block.
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:68:34: note: === vect_analyze_data_refs ===
main.c:68:34: note: got vectype for stmt: _200 = *_199;
vector(4) int
main.c:68:34: note: not vectorized: not enough data-refs in basic block.
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:68:34: note: === vect_analyze_data_refs ===
main.c:68:34: note: not vectorized: not enough data-refs in basic block.
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:69:15: note: === vect_analyze_data_refs ===
main.c:69:15: note: not vectorized: no vectype for stmt: vect__4.80_243 = MEM[(int *)vectp_arr.78_241];
 scalar_type: vector(4) int
main.c:69:15: note: not vectorized: not enough data-refs in basic block.
main.c:69:15: note: ===vect_slp_analyze_bb===
main.c:69:15: note: ===vect_slp_analyze_bb===
main.c:69:15: note: ===vect_slp_analyze_bb===
main.c:69:15: note: === vect_analyze_data_refs ===
main.c:69:15: note: not vectorized: not enough data-refs in basic block.
main.c:69:15: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _414 = *_413;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _423 = *_422;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _432 = *_431;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _441 = *_440;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _450 = *_449;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _459 = *_458;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:5: note: === vect_analyze_data_refs ===
main.c:68:5: note: got vectype for stmt: _468 = *_467;
vector(4) int
main.c:68:5: note: not vectorized: not enough data-refs in basic block.
main.c:68:5: note: ===vect_slp_analyze_bb===
main.c:68:34: note: === vect_analyze_data_refs ===
main.c:68:34: note: got vectype for stmt: _223 = *_222;
vector(4) int
main.c:68:34: note: not vectorized: not enough data-refs in basic block.
main.c:68:34: note: ===vect_slp_analyze_bb===
main.c:15:24: note: === vect_analyze_data_refs ===
main.c:15:24: note: not vectorized: not enough data-refs in basic block.
main.c:15:24: note: ===vect_slp_analyze_bb===
main.c:78:5: note: === vect_analyze_data_refs ===
main.c:78:5: note: got vectype for stmt: block_arr_78->array = _80;
vector(2) long unsigned int
main.c:78:5: note: got vectype for stmt: block_arr_78->n_elem = 0;
vector(2) long unsigned int
main.c:78:5: note: got vectype for stmt: block_arr_78->max_elem = size_35(D);
vector(2) long unsigned int
main.c:78:5: note: got vectype for stmt: buckets[i_138] = block_arr_78;
vector(2) long unsigned int
main.c:78:5: note: === vect_analyze_data_ref_accesses ===
main.c:78:5: note: Detected interleaving store block_arr_78->n_elem and block_arr_78->max_elem
main.c:78:5: note: not consecutive access block_arr_78->array = _80;
main.c:78:5: note: Detected interleaving store of size 2 starting with block_arr_78->n_elem = 0;
main.c:78:5: note: === vect_pattern_recog ===
main.c:78:5: note: === vect_analyze_slp ===
main.c:78:5: note: Build SLP for block_arr_78->n_elem = 0;
main.c:78:5: note: Build SLP for block_arr_78->max_elem = size_35(D);
main.c:78:5: note: Build SLP failed: different operation in stmt block_arr_78->max_elem = size_35(D);
main.c:78:5: note: original stmt block_arr_78->n_elem = 0;
main.c:78:5: note: ===vect_slp_analyze_bb===
main.c:78:5: note: ===vect_slp_analyze_bb===
main.c:78:5: note: === vect_analyze_data_refs ===
main.c:78:5: note: not vectorized: not enough data-refs in basic block.
main.c:78:5: note: ===vect_slp_analyze_bb===
main.c:47:7: note: === vect_analyze_data_refs ===
main.c:47:7: note: got vectype for stmt: _8 = *_7;
vector(4) int
main.c:47:7: note: got vectype for stmt: _15 = buckets[n_bucket_45];
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: _81 = _15->n_elem;
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: _82 = _15->max_elem;
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: pretmp_160 = _15->array;
vector(2) long unsigned int
main.c:47:7: note: === vect_analyze_data_ref_accesses ===
main.c:47:7: note: Detected interleaving load _15->n_elem and _15->max_elem
main.c:47:7: note: not consecutive access _15 = buckets[n_bucket_45];
main.c:47:7: note: not consecutive access pretmp_160 = _15->array;
main.c:47:7: note: Detected interleaving load of size 2 starting with _81 = _15->n_elem;
main.c:47:7: note: not vectorized: no grouped stores in basic block.
main.c:47:7: note: ===vect_slp_analyze_bb===
main.c:48:22: note: === vect_analyze_data_refs ===
main.c:48:22: note: not vectorized: not enough data-refs in basic block.
main.c:49:23: note: === vect_analyze_data_refs ===
main.c:49:23: note: got vectype for stmt: _15->array = _85;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: _15->max_elem = _87;
vector(2) long unsigned int
main.c:49:23: note: === vect_analyze_data_ref_accesses ===
main.c:49:23: note: not consecutive access _15->array = _85;
main.c:49:23: note: not consecutive access _15->max_elem = _87;
main.c:49:23: note: not vectorized: no grouped stores in basic block.
main.c:49:23: note: ===vect_slp_analyze_bb===
main.c:81:5: note: === vect_analyze_data_refs ===
main.c:81:5: note: got vectype for stmt: *_91 = _8;
vector(4) int
main.c:81:5: note: got vectype for stmt: _15->n_elem = _92;
vector(2) long unsigned int
main.c:81:5: note: === vect_analyze_data_ref_accesses ===
main.c:81:5: note: not consecutive access *_91 = _8;
main.c:81:5: note: not consecutive access _15->n_elem = _92;
main.c:81:5: note: not vectorized: no grouped stores in basic block.
main.c:81:5: note: ===vect_slp_analyze_bb===
main.c:81:5: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _322 = buckets[i_319];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _323 = _322->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _322 = buckets[i_319];
main.c:93:12: note: not consecutive access _323 = _322->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _324 = _322->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _332 = buckets[i_327];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _333 = _332->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _332 = buckets[i_327];
main.c:93:12: note: not consecutive access _333 = _332->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _334 = _332->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _342 = buckets[i_337];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _343 = _342->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _342 = buckets[i_337];
main.c:93:12: note: not consecutive access _343 = _342->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _344 = _342->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _352 = buckets[i_347];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _353 = _352->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _352 = buckets[i_347];
main.c:93:12: note: not consecutive access _353 = _352->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _354 = _352->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _362 = buckets[i_357];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _363 = _362->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _362 = buckets[i_357];
main.c:93:12: note: not consecutive access _363 = _362->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _364 = _362->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _372 = buckets[i_367];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _373 = _372->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _372 = buckets[i_367];
main.c:93:12: note: not consecutive access _373 = _372->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _374 = _372->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _382 = buckets[i_377];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _383 = _382->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _382 = buckets[i_377];
main.c:93:12: note: not consecutive access _383 = _382->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _384 = _382->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _392 = buckets[i_387];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _393 = _392->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _392 = buckets[i_387];
main.c:93:12: note: not consecutive access _393 = _392->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _394 = _392->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _402 = buckets[i_397];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _403 = _402->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _402 = buckets[i_397];
main.c:93:12: note: not consecutive access _403 = _402->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _404 = _402->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:93:12: note: === vect_analyze_data_refs ===
main.c:93:12: note: got vectype for stmt: _16 = buckets[i_407];
vector(2) long unsigned int
main.c:93:12: note: got vectype for stmt: _17 = _16->n_elem;
vector(2) long unsigned int
main.c:93:12: note: === vect_analyze_data_ref_accesses ===
main.c:93:12: note: not consecutive access _16 = buckets[i_407];
main.c:93:12: note: not consecutive access _17 = _16->n_elem;
main.c:93:12: note: not vectorized: no grouped stores in basic block.
main.c:93:12: note: ===vect_slp_analyze_bb===
main.c:94:13: note: === vect_analyze_data_refs ===
main.c:94:13: note: got vectype for stmt: _19 = _16->array;
vector(2) long unsigned int
main.c:94:13: note: not vectorized: not enough data-refs in basic block.
main.c:94:13: note: ===vect_slp_analyze_bb===
main.c:92:40: note: === vect_analyze_data_refs ===
main.c:92:40: note: not vectorized: not enough data-refs in basic block.
main.c:92:40: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: got vectype for stmt: _55 = _130->array;
vector(2) long unsigned int
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:35: note: === vect_analyze_data_refs ===
main.c:35:35: note: not vectorized: not enough data-refs in basic block.
main.c:35:35: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _302 = *_298;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_301 = _302;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_301 = _302;
main.c:35:22: note: not consecutive access _302 = *_298;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _315 = *_311;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_314 = _315;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_314 = _315;
main.c:35:22: note: not consecutive access _315 = *_311;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: got vectype for stmt: _54 = *_66;
vector(4) int
main.c:35:22: note: got vectype for stmt: *_56 = _54;
vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not consecutive access *_56 = _54;
main.c:35:22: note: not consecutive access _54 = *_66;
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: not enough data-refs in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: no vectype for stmt: vect__63.68_185 = MEM[(int *)vectp.66_183];
 scalar_type: vector(4) int
main.c:35:22: note: not vectorized: no vectype for stmt: MEM[(int *)vectp.69_189] = vect__63.68_185;
 scalar_type: vector(4) int
main.c:35:22: note: === vect_analyze_data_ref_accesses ===
main.c:35:22: note: not vectorized: no grouped stores in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:35:22: note: === vect_analyze_data_refs ===
main.c:35:22: note: not vectorized: not enough data-refs in basic block.
main.c:35:22: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _70 = *_228;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_27 = _70;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_27 = _70;
main.c:34:9: note: not consecutive access _70 = *_228;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _62 = *_57;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_61 = _62;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_61 = _62;
main.c:34:9: note: not consecutive access _62 = *_57;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _268 = *_264;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_267 = _268;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_267 = _268;
main.c:34:9: note: not consecutive access _268 = *_264;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _279 = *_275;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_278 = _279;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_278 = _279;
main.c:34:9: note: not consecutive access _279 = *_275;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _290 = *_286;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_289 = _290;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access *_289 = _290;
main.c:34:9: note: not consecutive access _290 = *_286;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:62: note: === vect_analyze_data_refs ===
main.c:34:62: note: got vectype for stmt: _150 = *_162;
vector(4) int
main.c:34:62: note: got vectype for stmt: *_151 = _150;
vector(4) int
main.c:34:62: note: === vect_analyze_data_ref_accesses ===
main.c:34:62: note: not consecutive access *_151 = _150;
main.c:34:62: note: not consecutive access _150 = *_162;
main.c:34:62: note: not vectorized: no grouped stores in basic block.
main.c:34:62: note: ===vect_slp_analyze_bb===
main.c:34:62: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _107 = *_111;
vector(4) int
main.c:34:9: note: got vectype for stmt: *_108 = _107;
vector(4) int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: not vectorized: not enough data-refs in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:30:5: note: === vect_analyze_data_refs ===
main.c:30:5: note: not vectorized: not enough data-refs in basic block.
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:30:5: note: ===vect_slp_analyze_bb===
main.c:34:9: note: === vect_analyze_data_refs ===
main.c:34:9: note: got vectype for stmt: _130 = *_129;
vector(2) long unsigned int
main.c:34:9: note: got vectype for stmt: _18 = _130->n_elem;
vector(2) long unsigned int
main.c:34:9: note: === vect_analyze_data_ref_accesses ===
main.c:34:9: note: not consecutive access _18 = _130->n_elem;
main.c:34:9: note: not vectorized: no grouped stores in basic block.
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:34:9: note: ===vect_slp_analyze_bb===
main.c:23:5: note: === vect_analyze_data_refs ===
main.c:23:5: note: got vectype for stmt: _20 = buckets[i_141];
vector(2) long unsigned int
main.c:23:5: note: got vectype for stmt: _72 = _20->array;
vector(2) long unsigned int
main.c:23:5: note: === vect_analyze_data_ref_accesses ===
main.c:23:5: note: not consecutive access _72 = _20->array;
main.c:23:5: note: not vectorized: no grouped stores in basic block.
main.c:98:5: note: === vect_analyze_data_refs ===
main.c:98:5: note: not vectorized: not enough data-refs in basic block.
main.c:98:5: note: ===vect_slp_analyze_bb===
main.c:98:5: note: ===vect_slp_analyze_bb===
main.c:101:1: note: === vect_analyze_data_refs ===
main.c:101:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:104
main.c:104:5: note: ===== analyze_loop_nest =====
main.c:104:5: note: === vect_analyze_loop_form ===
main.c:104:5: note: === get_loop_niters ===
main.c:104:5: note: Symbolic number of iterations is size_7(D)
main.c:104:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed
main.c:103:6: note: vectorized 0 loops in function.
main.c:103:6: note: ===vect_slp_analyze_bb===
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:106:9: note: === vect_analyze_data_refs ===
main.c:106:9: note: got vectype for stmt: _3 = *_2;
vector(4) int
main.c:106:9: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:108:1: note: === vect_analyze_data_refs ===
main.c:108:1: note: not vectorized: not enough data-refs in basic block.

Analyzing loop at main.c:104
main.c:104:5: note: ===== analyze_loop_nest =====
main.c:104:5: note: === vect_analyze_loop_form ===
main.c:104:5: note: === get_loop_niters ===
main.c:104:5: note: Symbolic number of iterations is size_14
main.c:104:5: note: not vectorized: loop contains function calls or data references that cannot be analyzed

Analyzing loop at main.c:116
main.c:116:11: note: ===== analyze_loop_nest =====
main.c:116:11: note: === vect_analyze_loop_form ===
main.c:116:11: note: not vectorized: control flow in loop.
main.c:116:11: note: bad loop form.
main.c:111:5: note: vectorized 0 loops in function.
main.c:111:5: note: ===vect_slp_analyze_bb===
main.c:114:11: note: === vect_analyze_data_refs ===
main.c:114:11: note: got vectype for stmt: _1 = MEM[(char * *)argv_10(D) + 8B];
vector(2) long unsigned int
main.c:114:11: note: not vectorized: not enough data-refs in basic block.
main.c:114:11: note: ===vect_slp_analyze_bb===
main.c:47:7: note: === vect_analyze_data_refs ===
main.c:47:7: note: got vectype for stmt: v.3_2 = v;
vector(4) int
main.c:47:7: note: got vectype for stmt: _29 = b_9->n_elem;
vector(2) long unsigned int
main.c:47:7: note: got vectype for stmt: _30 = b_9->max_elem;
vector(2) long unsigned int
main.c:47:7: note: === vect_analyze_data_ref_accesses ===
main.c:47:7: note: Detected interleaving load b_9->n_elem and b_9->max_elem
main.c:47:7: note: not consecutive access v.3_2 = v;
main.c:47:7: note: Detected interleaving load of size 2 starting with _29 = b_9->n_elem;
main.c:47:7: note: not vectorized: no grouped stores in basic block.
main.c:47:7: note: ===vect_slp_analyze_bb===
main.c:47:7: note: === vect_analyze_data_refs ===
main.c:47:7: note: got vectype for stmt: pretmp_56 = b_9->array;
vector(2) long unsigned int
main.c:47:7: note: not vectorized: not enough data-refs in basic block.
main.c:47:7: note: ===vect_slp_analyze_bb===
main.c:48:22: note: === vect_analyze_data_refs ===
main.c:48:22: note: got vectype for stmt: _32 = b_9->array;
vector(2) long unsigned int
main.c:48:22: note: not vectorized: not enough data-refs in basic block.
main.c:49:23: note: === vect_analyze_data_refs ===
main.c:49:23: note: got vectype for stmt: b_9->array = _33;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: _34 = b_9->max_elem;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: b_9->max_elem = _35;
vector(2) long unsigned int
main.c:49:23: note: got vectype for stmt: pretmp_58 = b_9->n_elem;
vector(2) long unsigned int
main.c:49:23: note: === vect_analyze_data_ref_accesses ===
main.c:49:23: note: Detected interleaving load b_9->n_elem and b_9->max_elem
main.c:49:23: note: Detected interleaving load of size 2 starting with pretmp_58 = b_9->n_elem;
main.c:49:23: note: not consecutive access b_9->array = _33;
main.c:49:23: note: not consecutive access b_9->max_elem = _35;
main.c:49:23: note: not vectorized: no grouped stores in basic block.
main.c:49:23: note: ===vect_slp_analyze_bb===
main.c:52:16: note: === vect_analyze_data_refs ===
main.c:52:16: note: got vectype for stmt: *_39 = v.3_2;
vector(4) int
main.c:52:16: note: got vectype for stmt: b_9->n_elem = _40;
vector(2) long unsigned int
main.c:52:16: note: === vect_analyze_data_ref_accesses ===
main.c:52:16: note: not consecutive access *_39 = v.3_2;
main.c:52:16: note: not consecutive access b_9->n_elem = _40;
main.c:52:16: note: not vectorized: no grouped stores in basic block.
main.c:52:16: note: ===vect_slp_analyze_bb===
main.c:116:11: note: === vect_analyze_data_refs ===
main.c:116:11: note: not vectorized: not enough data-refs in basic block.
main.c:116:11: note: ===vect_slp_analyze_bb===
main.c:127:5: note: === vect_analyze_data_refs ===
main.c:127:5: note: got vectype for stmt: size_14 = b_9->n_elem;
vector(2) long unsigned int
main.c:127:5: note: got vectype for stmt: _4 = b_9->array;
vector(2) long unsigned int
main.c:127:5: note: === vect_analyze_data_ref_accesses ===
main.c:127:5: note: not consecutive access _4 = b_9->array;
main.c:127:5: note: not consecutive access size_14 = b_9->n_elem;
main.c:127:5: note: not vectorized: no grouped stores in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: got vectype for stmt: _5 = b_9->array;
vector(2) long unsigned int
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:106:9: note: === vect_analyze_data_refs ===
main.c:106:9: note: got vectype for stmt: _23 = *_22;
vector(4) int
main.c:106:9: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: === vect_analyze_data_refs ===
main.c:104:5: note: not vectorized: not enough data-refs in basic block.
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:104:5: note: ===vect_slp_analyze_bb===
main.c:23:5: note: === vect_analyze_data_refs ===
main.c:23:5: note: got vectype for stmt: _19 = b_9->array;
vector(2) long unsigned int
main.c:23:5: note: not vectorized: not enough data-refs in basic block.
main.c:111:5: note: === vect_analyze_data_refs ===
main.c:111:5: note: not vectorized: not enough data-refs in basic block.
